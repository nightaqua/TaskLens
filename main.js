/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SemesterDashboardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");

// services/TaskManager.ts
var import_obsidian = require("obsidian");

// models/Task.ts
function getTaskStatus(task) {
  if (task.completed)
    return "completed" /* Completed */;
  if (task.dueDate) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const due = new Date(task.dueDate);
    due.setHours(0, 0, 0, 0);
    if (due < today)
      return "overdue" /* Overdue */;
    const diffTime = due.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    if (diffDays <= 3 && diffDays >= 0)
      return "urgent" /* Urgent */;
    return "upcoming_week" /* UpcomingWeek */;
  }
  return "no_date" /* NoDate */;
}

// services/TaskManager.ts
var TaskManager = class extends import_obsidian.Events {
  constructor(parser, app) {
    super();
    this.parser = parser;
    this.app = app;
    this.tasks = [];
    this.filteredTasks = [];
    this.currentStatusFilter = "open" /* Open */;
    this.currentCourseFilter = null;
    this.currentSortBy = "due-date" /* DueDate */;
  }
  async loadTasks() {
    this.tasks = await this.parser.findAllTasks();
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  /**
   * Toggle a task's completion state in its file
   */
  async toggleTaskCompletion(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber]) {
        lines[task.lineNumber] = lines[task.lineNumber].includes("[x]") ? lines[task.lineNumber].replace("[x]", "[ ]") : lines[task.lineNumber].replace("[ ]", "[x]");
        await this.app.vault.modify(file, lines.join("\n"));
        await this.refreshFileTask(task.filePath);
      }
    }
  }
  // ... inside TaskManager class ...
  /**
   * Delete a task from its file
   */
  async deleteTask(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber] && lines[task.lineNumber].includes(task.title)) {
        lines.splice(task.lineNumber, 1);
        await this.app.vault.modify(file, lines.join("\n"));
        await this.refreshFileTask(task.filePath);
      } else {
        console.warn("Task line mismatch, skipping delete to prevent data loss.");
      }
    }
  }
  /**
   * Update a task's title and/or due date
   */
  async updateTask(task, newTitle, newDate) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber]) {
        const originalLine = lines[task.lineNumber];
        const match = originalLine.match(/^(\s*-\s\[.\]\s)(.*)$/);
        if (match) {
          const prefix = match[1];
          let newLine = `${prefix}${newTitle}`;
          if (newDate) {
            const dateStr = this.formatDate(newDate);
            newLine += ` [due:: ${dateStr}]`;
          }
          lines[task.lineNumber] = newLine;
          await this.app.vault.modify(file, lines.join("\n"));
          await this.refreshFileTask(task.filePath);
        }
      }
    }
  }
  async refreshFileTask(filePath) {
    const fileTasks = await this.parser.getTasksFromFile(filePath);
    this.tasks = this.tasks.filter((t) => t.filePath !== filePath);
    this.tasks.push(...fileTasks);
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  getAllTasks() {
    return [...this.tasks];
  }
  getFilteredTasks() {
    return [...this.filteredTasks];
  }
  getStatistics() {
    const total = this.tasks.length;
    const completed = this.tasks.filter((t) => t.completed).length;
    const overdue = this.tasks.filter((t) => getTaskStatus(t) === "overdue" /* Overdue */).length;
    const upcoming = this.tasks.filter((t) => getTaskStatus(t) === "upcoming_week" /* UpcomingWeek */).length;
    const urgent = this.tasks.filter((t) => getTaskStatus(t) === "urgent" /* Urgent */).length;
    const courses = new Set(this.tasks.map((t) => t.fileName)).size;
    return { total, completed, overdue, upcoming, urgent, courses };
  }
  getCourseNames() {
    return Array.from(new Set(this.tasks.map((t) => t.fileName))).sort();
  }
  setStatusFilter(status) {
    this.currentStatusFilter = status;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  setCourseFilter(course) {
    this.currentCourseFilter = course;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  setSortBy(sortBy) {
    this.currentSortBy = sortBy;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  getCurrentFilters() {
    return {
      status: this.currentStatusFilter,
      course: this.currentCourseFilter,
      sortBy: this.currentSortBy
    };
  }
  async addTask(title, date, filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      let content = await this.app.vault.read(file);
      let taskLine = `
- [ ] ${title}`;
      if (date) {
        const dateStr = this.formatDate(date);
        taskLine += ` [due:: ${dateStr}]`;
      }
      await this.app.vault.modify(file, content + taskLine);
      await this.refreshFileTask(filePath);
    }
  }
  formatDate(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  applyFiltersAndSort() {
    this.filteredTasks = this.tasks.filter((task) => {
      if (this.currentStatusFilter !== "all" /* All */) {
        if (this.currentStatusFilter === "open" /* Open */) {
          if (task.completed)
            return false;
        } else {
          if (getTaskStatus(task) !== this.currentStatusFilter)
            return false;
        }
      }
      if (this.currentCourseFilter && task.fileName !== this.currentCourseFilter)
        return false;
      return true;
    });
    this.filteredTasks.sort((a, b) => {
      const weightA = this.getStatusWeight(a);
      const weightB = this.getStatusWeight(b);
      if (weightA !== weightB)
        return weightA - weightB;
      if (a.dueDate && b.dueDate)
        return a.dueDate.getTime() - b.dueDate.getTime();
      if (a.dueDate)
        return -1;
      if (b.dueDate)
        return 1;
      return 0;
    });
  }
  getStatusWeight(task) {
    const status = getTaskStatus(task);
    switch (status) {
      case "overdue" /* Overdue */:
        return 1;
      case "urgent" /* Urgent */:
        return 2;
      case "upcoming_week" /* UpcomingWeek */:
        return 3;
      case "no_date" /* NoDate */:
        return 4;
      case "completed" /* Completed */:
        return 5;
      default:
        return 3;
    }
  }
};

// services/TaskParser.ts
var import_obsidian2 = require("obsidian");
var TaskParser = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * RENAMED: Matches TaskManager.loadTasks()
   */
  async findAllTasks() {
    const tasks = [];
    const filesToScan = this.getFilesToScan();
    for (const file of filesToScan) {
      const fileTasks = await this.parseTasksFromFile(file);
      tasks.push(...fileTasks);
    }
    return tasks;
  }
  /**
   * RENAMED: Matches TaskManager.refreshFileTask()
   */
  async getTasksFromFile(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian2.TFile) {
      return this.parseTasksFromFile(file);
    }
    return [];
  }
  // --- Private Helpers ---
  getFilesToScan() {
    const allMarkdownFiles = this.app.vault.getMarkdownFiles();
    if (this.settings.scanFolders.length === 0) {
      return allMarkdownFiles;
    }
    return allMarkdownFiles.filter((file) => {
      return this.settings.scanFolders.some((folder) => {
        var _a;
        const normalizedFolder = folder.replace(/^\/|\/$/g, "");
        const filePath = file.path;
        if (this.settings.scanRecursively) {
          return filePath.startsWith(normalizedFolder);
        } else {
          const fileFolder = ((_a = file.parent) == null ? void 0 : _a.path) || "";
          return fileFolder === normalizedFolder;
        }
      });
    });
  }
  async parseTasksFromFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const cache = this.app.metadataCache.getFileCache(file);
    const courseName = this.getCourseName(file, cache);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const taskMatch = line.match(/^(\s*)-\s\[([ xX])\]\s(.+)$/);
      if (taskMatch) {
        const completed = taskMatch[2].toLowerCase() === "x";
        const taskText = taskMatch[3];
        const { title, startDate, dueDate } = this.parseTaskMetadata(taskText);
        const task = {
          id: `${file.path}:${i}`,
          title,
          completed,
          filePath: file.path,
          fileName: courseName,
          lineNumber: i,
          startDate,
          dueDate,
          originalText: line
        };
        tasks.push(task);
      }
    }
    return tasks;
  }
  getCourseName(file, cache) {
    var _a;
    switch (this.settings.courseDetection) {
      case "per-file":
        return file.basename;
      case "per-folder":
        return ((_a = file.parent) == null ? void 0 : _a.name) || file.basename;
      case "frontmatter":
        if (cache == null ? void 0 : cache.frontmatter) {
          const val = cache.frontmatter[this.settings.courseFrontmatterKey];
          if (val)
            return String(val);
        }
        return file.basename;
      default:
        return file.basename;
    }
  }
  parseTaskMetadata(taskText) {
    let title = taskText;
    let startDate;
    let dueDate;
    const startRegex = /\[?\(?start::\s*(\d{4}-\d{2}-\d{2})[\]\)]?/gi;
    const startMatch = startRegex.exec(taskText);
    if (startMatch) {
      startDate = new Date(startMatch[1]);
      title = title.replace(startRegex, "");
    }
    const dueRegex = /\[?\(?due::\s*(\d{4}-\d{2}-\d{2})[\]\)]?/gi;
    const dueMatch = dueRegex.exec(taskText);
    if (dueMatch) {
      dueDate = new Date(dueMatch[1]);
      title = title.replace(dueRegex, "");
    }
    if (!dueDate) {
      const emojiMatch = taskText.match(/ðŸ“…\s*(\d{4}-\d{2}-\d{2})/);
      if (emojiMatch) {
        dueDate = new Date(emojiMatch[1]);
        title = title.replace(/ðŸ“…\s*\d{4}-\d{2}-\d{2}\s*/g, "");
      }
    }
    title = title.replace(/\s+/g, " ").trim();
    return { title, startDate, dueDate };
  }
};

// settings/Settings.ts
var DEFAULT_SETTINGS = {
  // Scanning Defaults
  scanFolders: [],
  scanRecursively: true,
  courseDetection: "per-file",
  courseFrontmatterKey: "course",
  startDateKey: "start",
  dueDateKey: "due",
  // Visual Defaults
  colorScheme: "inherit",
  colorMode: "status",
  colors: {
    overdue: "#e63946",
    urgent: "#fb8500",
    active: "#2a9d8f",
    completed: "#457b9d"
  },
  // Default palette for courses
  courseColors: ["#4cc9f0", "#f72585", "#7209b7", "#3a0ca3", "#4361ee", "#4caf50"],
  hasSeenWelcome: false
};

// settings/SettingsTab.ts
var import_obsidian3 = require("obsidian");
var SettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("semester-dashboard-settings");
    containerEl.createEl("h2", { text: "TaskLens Settings" });
    const scanDetails = containerEl.createEl("details");
    scanDetails.open = true;
    scanDetails.createEl("summary", { text: "Vault Scanning" });
    const scanPathsSetting = new import_obsidian3.Setting(scanDetails).setName("Scan paths").setDesc("Folders (e.g. Uni/Math)\nor specific files (e.g. Projects/Todo.md).\n\nOne per line.\nLeave empty to scan entire vault.").addTextArea((text) => {
      text.setPlaceholder("Projects\nUni/History\nTo-Do.md").setValue(this.plugin.settings.scanFolders.join("\n")).onChange(async (value) => {
        this.plugin.settings.scanFolders = value.split("\n").map((s) => s.trim()).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
    });
    scanPathsSetting.settingEl.addClass("scan-paths-setting");
    new import_obsidian3.Setting(scanDetails).setName("Recursive Scan").setDesc("Scan all subfolders inside the folders specified above?").addToggle((t) => t.setValue(this.plugin.settings.scanRecursively).onChange(async (v) => {
      this.plugin.settings.scanRecursively = v;
      await this.plugin.saveSettings();
    }));
    const parserDetails = containerEl.createEl("details");
    parserDetails.createEl("summary", { text: "Task Parsing" });
    new import_obsidian3.Setting(parserDetails).setName("Start Key").addText((t) => t.setValue(this.plugin.settings.startDateKey).onChange(async (v) => {
      this.plugin.settings.startDateKey = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(parserDetails).setName("Due Key").addText((t) => t.setValue(this.plugin.settings.dueDateKey).onChange(async (v) => {
      this.plugin.settings.dueDateKey = v;
      await this.plugin.saveSettings();
    }));
    const uiDetails = containerEl.createEl("details");
    uiDetails.open = true;
    uiDetails.createEl("summary", { text: "Appearance & Colors" });
    new import_obsidian3.Setting(uiDetails).setName("Overdue Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.overdue).onChange(async (v) => {
      this.plugin.settings.colors.overdue = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
    new import_obsidian3.Setting(uiDetails).setName("Urgent Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.urgent).onChange(async (v) => {
      this.plugin.settings.colors.urgent = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
    new import_obsidian3.Setting(uiDetails).setName("Active Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.active).onChange(async (v) => {
      this.plugin.settings.colors.active = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
    new import_obsidian3.Setting(uiDetails).setName("Completed Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.completed).onChange(async (v) => {
      this.plugin.settings.colors.completed = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
    containerEl.createEl("hr");
    const supportDiv = containerEl.createDiv("support-section");
    supportDiv.style.textAlign = "center";
    supportDiv.style.padding = "20px 0";
    supportDiv.style.backgroundColor = "var(--background-secondary)";
    supportDiv.style.borderRadius = "8px";
    supportDiv.createEl("h3", { text: "Enjoying TaskLens?" });
    supportDiv.createEl("p", { text: "If this dashboard helps you stay organized, consider supporting its development!", cls: "text-muted" });
    const btn = supportDiv.createEl("a", { href: "https://buymeacoffee.com/joblessdev", text: "\u2615 Buy Me a Coffee", cls: "mod-cta" });
    btn.style.textDecoration = "none";
    btn.style.display = "inline-block";
    btn.style.marginTop = "10px";
    const bmcScript = supportDiv.createEl("script");
    bmcScript.setAttribute("type", "text/javascript");
    bmcScript.setAttribute("src", "https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js");
    bmcScript.setAttribute("data-name", "bmc-button");
    bmcScript.setAttribute("data-slug", "JoblessDev");
    bmcScript.setAttribute("data-color", "#40DCA5");
    bmcScript.setAttribute("data-emoji", "\u2615");
    bmcScript.setAttribute("data-font", "Poppins");
    bmcScript.setAttribute("data-text", "Buy me a coffee");
    bmcScript.setAttribute("data-outline-color", "#000000");
    bmcScript.setAttribute("data-font-color", "#ffffff");
    bmcScript.setAttribute("data-coffee-color", "#FFDD00");
  }
};

// views/DashboardView.ts
var import_obsidian7 = require("obsidian");

// views/TimelineComponent.ts
var import_obsidian4 = require("obsidian");
var TimelineComponent = class {
  constructor(container, app, tasks, daysToShow = 14) {
    this.scrollContainer = null;
    this.tooltipEl = null;
    // Drag state
    this.isDragging = false;
    this.startX = 0;
    this.scrollLeftPos = 0;
    this.container = container;
    this.app = app;
    this.tasks = tasks;
    this.daysToShow = daysToShow;
  }
  render() {
    this.container.empty();
    this.container.addClass("timeline-wrapper");
    const validTasks = this.tasks.filter((t) => t.dueDate && !isNaN(t.dueDate.getTime()));
    if (validTasks.length === 0) {
      const empty = this.container.createDiv("dashboard-empty-state");
      empty.createEl("p", { text: "No dated tasks to display." });
      return;
    }
    const dates = validTasks.map((t) => t.dueDate);
    dates.push(new Date());
    const minDate = new Date(Math.min(...dates.map((d) => d.getTime())));
    const maxDate = new Date(Math.max(...dates.map((d) => d.getTime())));
    minDate.setDate(minDate.getDate() - 2);
    maxDate.setDate(maxDate.getDate() + this.daysToShow + 2);
    const allDays = [];
    const curr = new Date(minDate);
    while (curr <= maxDate) {
      allDays.push(new Date(curr));
      curr.setDate(curr.getDate() + 1);
    }
    this.createNavigationOverlay("left");
    this.createNavigationOverlay("right");
    this.scrollContainer = this.container.createDiv("timeline-container");
    const scrollContent = this.scrollContainer.createDiv("timeline-scroll-content");
    const totalWidthPercent = allDays.length / this.daysToShow * 100;
    scrollContent.style.width = `${totalWidthPercent}%`;
    const colWidthPercent = 100 / allDays.length;
    const monthHeader = scrollContent.createDiv("timeline-month-row");
    let currentMonth = -1;
    let monthStartIdx = 0;
    allDays.forEach((day, idx) => {
      const m = day.getMonth();
      if (m !== currentMonth) {
        if (currentMonth !== -1) {
          const span2 = idx - monthStartIdx;
          const monthName2 = allDays[monthStartIdx].toLocaleString("default", { month: "long", year: "numeric" });
          const mDiv2 = monthHeader.createDiv("timeline-month-cell");
          mDiv2.setText(monthName2);
          mDiv2.style.width = `${span2 * colWidthPercent}%`;
          mDiv2.style.left = `${monthStartIdx * colWidthPercent}%`;
        }
        currentMonth = m;
        monthStartIdx = idx;
      }
    });
    const span = allDays.length - monthStartIdx;
    const monthName = allDays[monthStartIdx].toLocaleString("default", { month: "long", year: "numeric" });
    const mDiv = monthHeader.createDiv("timeline-month-cell");
    mDiv.setText(monthName);
    mDiv.style.width = `${span * colWidthPercent}%`;
    mDiv.style.left = `${monthStartIdx * colWidthPercent}%`;
    const grid = scrollContent.createDiv("timeline-grid");
    grid.style.gridTemplateColumns = `repeat(${allDays.length}, 1fr)`;
    allDays.forEach((day, idx) => {
      const cell = grid.createDiv("timeline-header-cell");
      cell.setText(day.getDate().toString());
      const dayName = day.toLocaleString("default", { weekday: "short" });
      cell.createDiv("timeline-day-name").setText(dayName);
      cell.style.gridColumn = `${idx + 1}`;
      cell.style.gridRow = `1`;
      const bgCell = grid.createDiv("timeline-bg-cell");
      bgCell.style.gridColumn = `${idx + 1}`;
      bgCell.style.gridRow = `2 / -1`;
      if (day.toDateString() === new Date().toDateString()) {
        cell.addClass("is-today");
        bgCell.addClass("is-today-bg");
        const marker = grid.createDiv("timeline-today-marker");
        marker.style.gridColumn = `${idx + 1}`;
        marker.style.gridRow = `1 / -1`;
      }
    });
    validTasks.forEach((task, rowIndex) => {
      const rowBg = grid.createDiv("timeline-row-bg");
      rowBg.style.gridColumn = `1 / -1`;
      rowBg.style.gridRow = `${rowIndex + 2}`;
      const dueIdx = allDays.findIndex((d) => d.toDateString() === task.dueDate.toDateString());
      if (dueIdx >= 0) {
        const bar = grid.createDiv("timeline-task-bar");
        bar.setText(task.title);
        const status = getTaskStatus(task);
        if (status === "overdue" /* Overdue */)
          bar.addClass("status-overdue");
        if (status === "urgent" /* Urgent */)
          bar.addClass("status-urgent");
        if (status === "completed" /* Completed */)
          bar.addClass("status-completed");
        if (status === "upcoming_week" /* UpcomingWeek */)
          bar.addClass("status-active");
        bar.style.gridColumnStart = `${dueIdx + 1}`;
        bar.style.gridColumnEnd = `span 1`;
        bar.style.gridRow = `${rowIndex + 2}`;
        bar.addEventListener("mouseenter", (e) => this.showTooltip(e, task));
        bar.addEventListener("mouseleave", () => this.hideTooltip());
        bar.addEventListener("mousemove", (e) => this.moveTooltip(e));
        bar.addEventListener("click", (e) => {
          e.stopPropagation();
          this.openTaskFile(task);
        });
      }
    });
    this.setupEventListeners(this.scrollContainer);
    this.scrollToToday();
  }
  scrollToToday() {
    setTimeout(() => {
      if (!this.scrollContainer)
        return;
      const todayCell = this.scrollContainer.querySelector(".timeline-header-cell.is-today");
      if (todayCell) {
        const scrollPos = todayCell.offsetLeft - this.scrollContainer.clientWidth / 2 + todayCell.clientWidth / 2;
        this.scrollContainer.scrollTo({ left: scrollPos, behavior: "smooth" });
      }
    }, 100);
  }
  // --- PUBLIC SCROLL METHOD (Fixes DashboardView error) ---
  scroll(direction) {
    if (!this.scrollContainer)
      return;
    const scrollAmount = this.scrollContainer.clientWidth * 0.8;
    this.scrollContainer.scrollBy({
      left: direction === "left" ? -scrollAmount : scrollAmount,
      behavior: "smooth"
    });
  }
  createNavigationOverlay(direction) {
    const overlay = this.container.createDiv(`timeline-nav-overlay nav-${direction}`);
    overlay.createDiv("nav-arrow").setText(direction === "left" ? "\u2039" : "\u203A");
    overlay.addEventListener("click", (e) => {
      e.stopPropagation();
      this.scroll(direction);
    });
  }
  setupEventListeners(container) {
    container.addEventListener("mousedown", (e) => {
      this.isDragging = true;
      container.addClass("is-dragging");
      this.startX = e.pageX - container.offsetLeft;
      this.scrollLeftPos = container.scrollLeft;
    });
    container.addEventListener("mouseleave", () => {
      this.isDragging = false;
      container.removeClass("is-dragging");
    });
    container.addEventListener("mouseup", () => {
      this.isDragging = false;
      container.removeClass("is-dragging");
    });
    container.addEventListener("mousemove", (e) => {
      if (!this.isDragging)
        return;
      e.preventDefault();
      const x = e.pageX - container.offsetLeft;
      const walk = (x - this.startX) * 1.5;
      container.scrollLeft = this.scrollLeftPos - walk;
    });
  }
  showTooltip(e, task) {
    if (!this.tooltipEl) {
      this.tooltipEl = document.body.createDiv("dashboard-tooltip");
    }
    this.tooltipEl.empty();
    this.tooltipEl.createDiv("tooltip-title").setText(task.title);
    this.tooltipEl.createDiv("tooltip-meta").setText(`\u{1F4C2} ${task.fileName}`);
    if (task.dueDate) {
      this.tooltipEl.createDiv("tooltip-date").setText(`\u{1F4C5} ${task.dueDate.toDateString()}`);
    }
    this.tooltipEl.style.display = "block";
    this.moveTooltip(e);
  }
  moveTooltip(e) {
    if (this.tooltipEl) {
      this.tooltipEl.style.top = `${e.clientY + 15}px`;
      this.tooltipEl.style.left = `${e.clientX + 15}px`;
    }
  }
  hideTooltip() {
    if (this.tooltipEl) {
      this.tooltipEl.style.display = "none";
    }
  }
  async openTaskFile(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file instanceof import_obsidian4.TFile) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      if (view) {
        view.editor.setCursor({ line: task.lineNumber, ch: 0 });
        view.editor.scrollIntoView({ from: { line: task.lineNumber, ch: 0 }, to: { line: task.lineNumber, ch: 0 } }, true);
      }
    }
  }
};

// views/TaskListComponent.ts
var import_obsidian5 = require("obsidian");
var TaskListComponent = class {
  // We need callbacks for the new actions
  constructor(container, app, callbacks) {
    this.container = container;
    this.app = app;
    this.callbacks = callbacks;
  }
  render(tasks, groupBy = "none") {
    this.container.empty();
    if (tasks.length === 0) {
      const empty = this.container.createDiv("dashboard-empty-state");
      empty.createEl("p", { text: "No tasks found." });
      return;
    }
    const listContainer = this.container.createDiv("dashboard-task-list");
    tasks.forEach((task) => {
      this.renderTaskItem(listContainer, task);
    });
  }
  renderTaskItem(container, task) {
    const status = getTaskStatus(task);
    let statusClass = "status-active";
    if (status === "overdue" /* Overdue */)
      statusClass = "status-overdue";
    if (status === "urgent" /* Urgent */)
      statusClass = "status-urgent";
    if (status === "completed" /* Completed */)
      statusClass = "status-completed";
    const taskEl = container.createDiv({ cls: ["task-item", statusClass] });
    const checkbox = taskEl.createEl("input", { type: "checkbox", cls: "task-checkbox" });
    checkbox.checked = task.completed;
    checkbox.addEventListener("change", () => this.callbacks.onToggle(task));
    const content = taskEl.createDiv("task-content");
    const viewMode = content.createDiv("task-view-mode");
    const titleEl = viewMode.createDiv("task-title");
    titleEl.setText(task.title);
    const meta = viewMode.createDiv("task-meta");
    meta.createSpan("task-course").setText(task.fileName);
    if (task.dueDate) {
      const d = task.dueDate.getDate().toString().padStart(2, "0");
      const m = (task.dueDate.getMonth() + 1).toString().padStart(2, "0");
      meta.createSpan("task-date").setText(`Due: ${d}-${m}-${task.dueDate.getFullYear()}`);
    }
    titleEl.addEventListener("click", () => this.openTaskInEditor(task));
    const actions = taskEl.createDiv("task-actions");
    const editBtn = actions.createEl("button", { cls: "task-action-btn" });
    (0, import_obsidian5.setIcon)(editBtn, "pencil");
    editBtn.setAttribute("aria-label", "Edit Task");
    const deleteBtn = actions.createEl("button", { cls: "task-action-btn btn-danger" });
    (0, import_obsidian5.setIcon)(deleteBtn, "trash-2");
    deleteBtn.setAttribute("aria-label", "Delete Task");
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.callbacks.onDelete(task);
    });
    editBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      viewMode.hide();
      actions.hide();
      const editMode = content.createDiv("task-edit-mode");
      const titleInput = editMode.createEl("input", {
        type: "text",
        value: task.title,
        cls: "task-edit-input"
      });
      const dateInput = editMode.createEl("input", {
        type: "date",
        cls: "task-edit-date"
      });
      if (task.dueDate) {
        const y = task.dueDate.getFullYear();
        const m = String(task.dueDate.getMonth() + 1).padStart(2, "0");
        const d = String(task.dueDate.getDate()).padStart(2, "0");
        dateInput.value = `${y}-${m}-${d}`;
      }
      const saveBtn = editMode.createEl("button", { cls: "task-save-btn", text: "Save" });
      const cancelBtn = editMode.createEl("button", { cls: "task-cancel-btn", text: "Cancel" });
      const save = () => {
        const newTitle = titleInput.value.trim();
        if (newTitle) {
          const newDate = dateInput.value ? new Date(dateInput.value) : null;
          this.callbacks.onEdit(task, newTitle, newDate);
        }
      };
      const cancel = () => {
        editMode.remove();
        viewMode.show();
        actions.show();
      };
      saveBtn.addEventListener("click", save);
      cancelBtn.addEventListener("click", cancel);
      titleInput.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter")
          save();
        if (evt.key === "Escape")
          cancel();
      });
      titleInput.focus();
    });
  }
  async openTaskInEditor(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        view.editor.setCursor({ line: task.lineNumber, ch: 0 });
        view.editor.scrollIntoView({ from: { line: task.lineNumber, ch: 0 }, to: { line: task.lineNumber, ch: 0 } }, true);
      }
    }
  }
};

// views/HeaderComponent.ts
var import_obsidian6 = require("obsidian");
var HeaderComponent = class {
  // <--- 1. Property added
  constructor(container, initialState, defaultTitle, callbacks) {
    this.headerEl = null;
    this.sidebarHandleEl = null;
    this.isSaving = false;
    this.container = container;
    this.defaultTitle = defaultTitle;
    this.title = initialState.title || defaultTitle;
    this.isCollapsed = initialState.isCollapsed || false;
    this.onStateChange = callbacks.onStateChange;
    this.onRefresh = callbacks.onRefresh;
    this.onSettings = callbacks.onSettings || null;
    this.onAdd = callbacks.onAdd || null;
  }
  render() {
    this.renderSidebarHandle();
    this.renderHeader();
    this.updateVisibility();
  }
  renderSidebarHandle() {
    if (this.sidebarHandleEl)
      this.sidebarHandleEl.remove();
    this.sidebarHandleEl = this.container.createDiv("dashboard-sidebar-handle is-hidden");
    (0, import_obsidian6.setIcon)(this.sidebarHandleEl, "panel-left-open");
    this.sidebarHandleEl.setAttribute("aria-label", "Show Header");
    this.sidebarHandleEl.addEventListener("click", () => {
      this.isCollapsed = false;
      this.updateVisibility();
      this.onStateChange();
    });
  }
  renderHeader() {
    if (this.headerEl)
      this.headerEl.remove();
    this.headerEl = this.container.createDiv("dashboard-header");
    const leftGroup = this.headerEl.createDiv("header-actions-left");
    if (this.onSettings) {
      const settingsBtn = leftGroup.createEl("button", { cls: "header-icon-btn" });
      (0, import_obsidian6.setIcon)(settingsBtn, "settings");
      settingsBtn.addEventListener("click", () => this.onSettings());
    }
    const titleWrapper = this.headerEl.createDiv("dashboard-title-wrapper");
    titleWrapper.setAttribute("aria-label", "Click to rename");
    const titleEl = titleWrapper.createEl("h2", { text: this.title });
    const editIcon = titleWrapper.createDiv("edit-title-icon");
    (0, import_obsidian6.setIcon)(editIcon, "pencil");
    titleWrapper.addEventListener("click", () => {
      this.enterEditMode(titleWrapper);
    });
    const rightGroup = this.headerEl.createDiv("header-actions-right");
    if (this.onAdd) {
      const addBtn = rightGroup.createEl("button", { cls: "header-icon-btn feature-highlight" });
      (0, import_obsidian6.setIcon)(addBtn, "plus");
      addBtn.setAttribute("aria-label", "Quick Add Task");
      addBtn.addEventListener("click", () => this.onAdd());
    }
    const refreshBtn = rightGroup.createEl("button", { cls: "dashboard-refresh-btn header-icon-btn" });
    (0, import_obsidian6.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.setAttribute("aria-label", "Refresh Data");
    refreshBtn.addEventListener("click", () => {
      refreshBtn.addClass("is-rotating");
      this.onRefresh();
      setTimeout(() => refreshBtn.removeClass("is-rotating"), 1e3);
    });
    const hideBtn = rightGroup.createEl("button", { cls: "header-icon-btn" });
    (0, import_obsidian6.setIcon)(hideBtn, "panel-top-close");
    hideBtn.setAttribute("aria-label", "Hide Header");
    hideBtn.addEventListener("click", () => {
      this.isCollapsed = true;
      this.updateVisibility();
      this.onStateChange();
    });
  }
  enterEditMode(wrapper) {
    wrapper.empty();
    const input = wrapper.createEl("input", {
      type: "text",
      value: this.title,
      cls: "dashboard-title-input"
    });
    input.focus();
    input.select();
    this.isSaving = false;
    const save = () => {
      if (this.isSaving)
        return;
      this.isSaving = true;
      const newVal = input.value.trim();
      this.title = newVal.length > 0 ? newVal : this.defaultTitle;
      this.onStateChange();
    };
    input.addEventListener("blur", save);
    input.addEventListener("keydown", (e) => {
      e.stopPropagation();
      if (e.key === "Enter") {
        e.preventDefault();
        save();
      }
    });
    input.addEventListener("keypress", (e) => e.stopPropagation());
  }
  updateVisibility() {
    var _a, _b, _c, _d;
    if (this.isCollapsed) {
      (_a = this.headerEl) == null ? void 0 : _a.addClass("is-collapsed");
      (_b = this.sidebarHandleEl) == null ? void 0 : _b.removeClass("is-hidden");
    } else {
      (_c = this.headerEl) == null ? void 0 : _c.removeClass("is-collapsed");
      (_d = this.sidebarHandleEl) == null ? void 0 : _d.addClass("is-hidden");
    }
  }
  getState() {
    return {
      title: this.title,
      isCollapsed: this.isCollapsed
    };
  }
};

// views/DashboardView.ts
var VIEW_TYPE_DASHBOARD = "semester-dashboard-view";
var DashboardView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.timelineComponent = null;
    // Ref to access scrollToToday
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    // UI State
    this.showControls = true;
    this.showTimeline = true;
    this.showList = true;
    this.showStats = true;
    this.timelineDaysToShow = 7;
    this.taskManager = this.plugin.taskManager;
    this.taskManager.on("tasks-updated", () => this.render());
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file.path.endsWith(".md"))
          this.taskManager.refreshFileTask(file.path);
      })
    );
    this.taskManager.setStatusFilter("open" /* Open */);
  }
  getViewType() {
    return VIEW_TYPE_DASHBOARD;
  }
  getDisplayText() {
    return "Personal Dashboard";
  }
  getIcon() {
    return "layout-dashboard";
  }
  // --- Persistence Logic ---
  async setState(state, result) {
    var _a, _b, _c, _d, _e;
    if (state) {
      this.showControls = (_a = state.showControls) != null ? _a : this.showControls;
      this.showTimeline = (_b = state.showTimeline) != null ? _b : this.showTimeline;
      this.showList = (_c = state.showList) != null ? _c : this.showList;
      this.showStats = (_d = state.showStats) != null ? _d : this.showStats;
      this.timelineDaysToShow = (_e = state.timelineDaysToShow) != null ? _e : this.timelineDaysToShow;
      if (state.statusFilter)
        this.taskManager.setStatusFilter(state.statusFilter);
      if (state.courseFilter)
        this.taskManager.setCourseFilter(state.courseFilter);
      if (state.headerState)
        this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    const filters = this.taskManager.getCurrentFilters();
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return {
      showControls: this.showControls,
      showTimeline: this.showTimeline,
      showList: this.showList,
      showStats: this.showStats,
      timelineDaysToShow: this.timelineDaysToShow,
      statusFilter: filters.status,
      courseFilter: filters.course,
      headerState: this.headerState
    };
  }
  // -------------------------
  async onOpen() {
    const parent = this.containerEl.closest(".workspace-leaf-content");
    if (parent)
      parent.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer)
      this.tabContainer.classList.add("semester-hide-tabs");
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl)
      this.leafRootEl.classList.add("semester-chromeless");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.applyColorTheme();
    await this.taskManager.loadTasks();
    this.render();
  }
  // 3. Remove class on close
  async onClose() {
    if (this.tabContainer)
      this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl)
      this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Personal Dashboard",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          if (this.headerState.isCollapsed) {
            this.showControls = false;
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.taskManager.loadTasks();
          if (this.timelineComponent) {
            this.timelineComponent.scrollToToday();
          }
        },
        onSettings: () => {
          this.showControls = !this.showControls;
          if (this.showControls && this.headerState.isCollapsed) {
            this.headerState.isCollapsed = false;
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        }
      }
    );
    this.headerComponent.render();
    this.renderControls();
    const layoutOrder = ["stats", "timeline", "list"];
    layoutOrder.forEach((component) => {
      if (component === "stats" && this.showStats)
        this.renderStatistics();
      if (component === "timeline" && this.showTimeline)
        this.renderTimeline();
      if (component === "list" && this.showList)
        this.renderTaskList();
    });
  }
  renderControls() {
    if (!this.showControls)
      return;
    const controls = this.contentEl.createDiv("dashboard-controls");
    const filtersDiv = controls.createDiv("filters-wrapper");
    filtersDiv.style.display = "flex";
    filtersDiv.style.gap = "12px";
    filtersDiv.style.flexWrap = "wrap";
    const statusGroup = filtersDiv.createDiv("control-group");
    statusGroup.createEl("label", { text: "Show:" });
    const statusSelect = statusGroup.createEl("select");
    const statusOptions = [
      { value: "open" /* Open */, label: "Active" },
      // Green
      { value: "all" /* All */, label: "All Tasks" },
      { value: "completed" /* Completed */, label: "Completed" }
    ];
    statusOptions.forEach((opt) => {
      const option = statusSelect.createEl("option", { value: opt.value, text: opt.label });
      if (opt.value === this.taskManager.getCurrentFilters().status)
        option.selected = true;
    });
    statusSelect.addEventListener("change", () => {
      this.taskManager.setStatusFilter(statusSelect.value);
    });
    const courseGroup = filtersDiv.createDiv("control-group");
    courseGroup.createEl("label", { text: "Topic:" });
    const courseSelect = courseGroup.createEl("select");
    courseSelect.createEl("option", { value: "", text: "All Topics" });
    this.taskManager.getCourseNames().forEach((course) => {
      const option = courseSelect.createEl("option", { value: course, text: course });
      if (course === this.taskManager.getCurrentFilters().course)
        option.selected = true;
    });
    courseSelect.addEventListener("change", () => {
      this.taskManager.setCourseFilter(courseSelect.value || null);
    });
    const actionsDiv = controls.createDiv("actions-wrapper");
    actionsDiv.style.display = "flex";
    actionsDiv.style.gap = "12px";
    actionsDiv.style.alignItems = "center";
    const toggleTimeline = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showTimeline ? "is-active" : ""}`,
      text: "Timeline"
    });
    toggleTimeline.addEventListener("click", () => {
      this.showTimeline = !this.showTimeline;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
    const toggleList = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showList ? "is-active" : ""}`,
      text: "List"
    });
    toggleList.addEventListener("click", () => {
      this.showList = !this.showList;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
    const statsBtn = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showStats ? "is-active" : ""}`,
      text: "Stats"
    });
    statsBtn.addEventListener("click", () => {
      this.showStats = !this.showStats;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
  }
  renderStatistics() {
    const stats = this.taskManager.getStatistics();
    const container = this.contentEl.createDiv("dashboard-stats");
    const statCards = [
      { label: "Total", value: stats.total, cls: "stat-total", filter: "all" /* All */ },
      { label: "Active", value: stats.upcoming, cls: "stat-active", filter: "upcoming_week" /* UpcomingWeek */ },
      { label: "Urgent", value: stats.urgent, cls: "stat-urgent", filter: "urgent" /* Urgent */ },
      { label: "Overdue", value: stats.overdue, cls: "stat-overdue", filter: "overdue" /* Overdue */ },
      { label: "Completed", value: stats.completed, cls: "stat-completed", filter: "completed" /* Completed */ }
    ];
    statCards.forEach((stat) => {
      const card = container.createDiv({ cls: ["stat-card", stat.cls] });
      card.addClass("is-clickable");
      card.addEventListener("click", () => {
        this.taskManager.setStatusFilter(stat.filter);
      });
      card.createDiv("stat-value").setText(String(stat.value));
      card.createDiv("stat-label").setText(stat.label);
    });
  }
  renderTaskList() {
    const container = this.contentEl.createDiv();
    const list = new TaskListComponent(container, this.app, {
      onToggle: (t) => this.taskManager.toggleTaskCompletion(t),
      onEdit: async (t, newTitle, newDate) => {
        await this.taskManager.updateTask(t, newTitle, newDate);
      },
      onDelete: async (t) => {
        await this.taskManager.deleteTask(t);
      }
    });
    list.render(this.taskManager.getFilteredTasks());
  }
  applyColorTheme() {
    const cols = this.plugin.settings.colors;
    this.contentEl.style.setProperty("--color-red", cols.overdue);
    this.contentEl.style.setProperty("--color-orange", cols.urgent);
    this.contentEl.style.setProperty("--color-green", cols.active);
    this.contentEl.style.setProperty("--color-blue", cols.completed);
    this.contentEl.style.setProperty("--color-purple", "#7209b7");
  }
  refreshFromSettings() {
    if (!this.contentEl.isConnected)
      return;
    this.applyColorTheme();
    this.render();
    this.app.workspace.requestSaveLayout();
  }
  renderTimeline() {
    const container = this.contentEl.createDiv("dashboard-timeline-view");
    const controls = container.createDiv("timeline-controls");
    const zoomControls = controls.createDiv("zoom-controls");
    zoomControls.createSpan({ text: "Zoom: " });
    const zoomOut = zoomControls.createEl("button", { text: "-", cls: "view-toggle-btn" });
    zoomOut.addEventListener("click", () => {
      this.timelineDaysToShow = Math.min(30, this.timelineDaysToShow + 1);
      this.render();
    });
    zoomControls.createSpan({ text: ` ${this.timelineDaysToShow} Days ` });
    const zoomIn = zoomControls.createEl("button", { text: "+", cls: "view-toggle-btn" });
    zoomIn.addEventListener("click", () => {
      this.timelineDaysToShow = Math.max(3, this.timelineDaysToShow - 1);
      this.render();
    });
    const navControls = controls.createDiv("nav-controls");
    const scrollLeft = navControls.createEl("button", { cls: "view-toggle-btn" });
    (0, import_obsidian7.setIcon)(scrollLeft, "chevron-left");
    const scrollRight = navControls.createEl("button", { cls: "view-toggle-btn" });
    (0, import_obsidian7.setIcon)(scrollRight, "chevron-right");
    this.timelineComponent = new TimelineComponent(
      container,
      this.app,
      this.taskManager.getFilteredTasks(),
      this.timelineDaysToShow
    );
    this.timelineComponent.render();
    scrollLeft.addEventListener("click", () => {
      var _a;
      return (_a = this.timelineComponent) == null ? void 0 : _a.scroll("left");
    });
    scrollRight.addEventListener("click", () => {
      var _a;
      return (_a = this.timelineComponent) == null ? void 0 : _a.scroll("right");
    });
  }
  async openTaskInEditor(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (view) {
        view.editor.setCursor({ line: task.lineNumber, ch: 0 });
        view.editor.scrollIntoView({ from: { line: task.lineNumber, ch: 0 }, to: { line: task.lineNumber, ch: 0 } }, true);
      }
    }
  }
};

// views/TimelineView.ts
var import_obsidian8 = require("obsidian");
var VIEW_TYPE_TIMELINE = "semester-timeline-view";
var TimelineView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.plugin.taskManager.on("tasks-updated", () => this.render());
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "Timeline";
  }
  getIcon() {
    return "calendar-range";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl)
      this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer)
      this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.contentEl.addClass("is-single-view");
    await this.plugin.taskManager.loadTasks();
    this.render();
  }
  async onClose() {
    if (this.tabContainer)
      this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl)
      this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Timeline",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        }
      }
    );
    this.headerComponent.render();
    const timeline = new TimelineComponent(this.contentEl, this.app, this.plugin.taskManager.getFilteredTasks(), 7);
    timeline.render();
  }
};

// views/TaskListView.ts
var import_obsidian10 = require("obsidian");

// modals/QuickAddModal.ts
var import_obsidian9 = require("obsidian");
var QuickAddModal = class extends import_obsidian9.Modal {
  constructor(app, taskManager) {
    super(app);
    this.taskManager = taskManager;
    this.title = "";
    this.date = "";
    this.selectedFile = "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Quick Add Task" });
    new import_obsidian9.Setting(contentEl).setName("Task").addText((text) => text.setPlaceholder("Read Chapter 4...").onChange((value) => this.title = value).inputEl.focus());
    new import_obsidian9.Setting(contentEl).setName("Course (File)").addDropdown((drop) => {
      const tasks = this.taskManager.getAllTasks();
      const knownFiles = tasks.map((t) => t.filePath);
      const uniqueFiles = Array.from(new Set(knownFiles));
      if (uniqueFiles.length > 0) {
        this.selectedFile = uniqueFiles[0];
        uniqueFiles.forEach((path) => {
          var _a;
          const name = ((_a = path.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || path;
          drop.addOption(path, name);
        });
      } else {
        drop.addOption("", "No course files found");
      }
      drop.setValue(this.selectedFile);
      drop.onChange((value) => this.selectedFile = value);
    });
    new import_obsidian9.Setting(contentEl).setName("Due Date").addText((text) => {
      text.inputEl.type = "date";
      text.onChange((value) => this.date = value);
    });
    new import_obsidian9.Setting(contentEl).addButton((btn) => btn.setButtonText("Add Task").setCta().onClick(async () => {
      if (!this.title || !this.selectedFile)
        return;
      const dateObj = this.date ? new Date(this.date) : null;
      await this.taskManager.addTask(this.title, dateObj, this.selectedFile);
      this.close();
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};

// views/TaskListView.ts
var VIEW_TYPE_LIST = "semester-list-view";
var TaskListView = class extends import_obsidian10.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.isOpen = false;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.onTasksUpdated = () => {
      var _a;
      if (!this.isOpen || !((_a = this.contentEl) == null ? void 0 : _a.isConnected))
        return;
      this.render();
    };
    this.plugin.taskManager.on("tasks-updated", this.onTasksUpdated);
  }
  getViewType() {
    return VIEW_TYPE_LIST;
  }
  getDisplayText() {
    return "Task List";
  }
  getIcon() {
    return "list-todo";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl)
      this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer)
      this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.contentEl.addClass("is-single-view");
    this.isOpen = true;
    this.render();
  }
  async onClose() {
    this.isOpen = false;
    if (this.tabContainer)
      this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl)
      this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    var _a;
    if (!this.isOpen || !((_a = this.contentEl) == null ? void 0 : _a.isConnected))
      return;
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "My Tasks",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        },
        // <--- Pass the callback to open the modal
        onAdd: () => {
          new QuickAddModal(this.app, this.plugin.taskManager).open();
        }
      }
    );
    this.headerComponent.render();
    const list = new TaskListComponent(this.contentEl, this.app, {
      onToggle: (t) => this.plugin.taskManager.toggleTaskCompletion(t),
      onEdit: async (t, newTitle, newDate) => {
        await this.plugin.taskManager.updateTask(t, newTitle, newDate);
      },
      onDelete: async (t) => {
        await this.plugin.taskManager.deleteTask(t);
      }
    });
    list.render(this.plugin.taskManager.getFilteredTasks());
  }
};

// views/StatsView.ts
var import_obsidian11 = require("obsidian");

// views/StatsComponent.ts
var StatsComponent = class {
  constructor(container) {
    this.container = container;
  }
  render(taskManager) {
    this.container.empty();
    const stats = taskManager.getStatistics();
    const tasks = taskManager.getAllTasks();
    const urgentCount = tasks.filter((t) => !t.completed && getTaskStatus(t) === "urgent" /* Urgent */).length;
    const containerDiv = this.container.createDiv("dashboard-stats");
    const statCards = [
      { label: "Total", value: stats.total, cls: "stat-total" },
      { label: "Active", value: stats.upcoming, cls: "stat-active" },
      { label: "Urgent", value: urgentCount, cls: "stat-urgent" },
      { label: "Overdue", value: stats.overdue, cls: "stat-overdue" },
      { label: "Completed", value: stats.completed, cls: "stat-completed" }
    ];
    statCards.forEach((stat) => {
      const card = containerDiv.createDiv({ cls: ["stat-card", stat.cls] });
      card.createDiv("stat-value").setText(String(stat.value));
      card.createDiv("stat-label").setText(stat.label);
    });
  }
};

// views/StatsView.ts
var VIEW_TYPE_STATS = "semester-stats-view";
var StatsView = class extends import_obsidian11.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.plugin.taskManager.on("tasks-updated", () => this.render());
  }
  getViewType() {
    return VIEW_TYPE_STATS;
  }
  getDisplayText() {
    return "Dashboard Stats";
  }
  getIcon() {
    return "bar-chart-3";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl)
      this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer)
      this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.render();
  }
  async onClose() {
    if (this.tabContainer)
      this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl)
      this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Statistics",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        }
      }
    );
    this.headerComponent.render();
    const stats = new StatsComponent(this.contentEl);
    stats.render(this.plugin.taskManager);
  }
};

// modals/WelcomeModal.ts
var import_obsidian12 = require("obsidian");
var WelcomeModal = class extends import_obsidian12.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("dashboard-welcome-modal");
    contentEl.createEl("h1", { text: "Welcome to Personal Dashboard! \u{1F680}" });
    contentEl.createEl("p", { text: "Your new command center for assignments, tasks, and deadlines." });
    const tutorial = contentEl.createDiv("welcome-tutorial");
    this.createStep(tutorial, "\u{1F4CA}", "Widgets", "Open different views (Timeline, List, Stats) using the command palette or ribbon icon.");
    this.createStep(tutorial, "\u{1F5B1}\uFE0F", "Drag & Drop", 'Click the "Move" icon in the left ribbon to unlock dragging. Arrange windows, then lock them back.');
    this.createStep(tutorial, "\u2795", "Quick Add", 'Click the "+" icon in any task list header to capture new tasks instantly.');
    this.createStep(tutorial, "\u{1F3A8}", "Customize", "Rename any widget by clicking its title. Hide headers for a clean look.");
    contentEl.createEl("hr");
    contentEl.createEl("p", { text: "You can find these settings and more in the plugin settings menu.", cls: "text-muted" });
    new import_obsidian12.Setting(contentEl).addButton((btn) => btn.setButtonText("Let's Go!").setCta().onClick(() => this.close()));
  }
  createStep(container, icon, title, desc) {
    const row = container.createDiv("welcome-step");
    row.style.display = "flex";
    row.style.gap = "15px";
    row.style.marginBottom = "15px";
    row.style.alignItems = "center";
    const iconEl = row.createDiv("step-icon");
    iconEl.setText(icon);
    iconEl.style.fontSize = "24px";
    const textDiv = row.createDiv("step-text");
    const titleEl = textDiv.createEl("h3", { text: title });
    titleEl.style.margin = "0 0 4px 0";
    textDiv.createEl("span", { text: desc, cls: "text-muted" });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// main.ts
var SemesterDashboardPlugin = class extends import_obsidian13.Plugin {
  async onload() {
    await this.loadSettings();
    const parser = new TaskParser(this.app, this.settings);
    this.taskManager = new TaskManager(parser, this.app);
    this.registerView(VIEW_TYPE_DASHBOARD, (leaf) => new DashboardView(leaf, this));
    this.registerView(VIEW_TYPE_TIMELINE, (leaf) => new TimelineView(leaf, this));
    this.registerView(VIEW_TYPE_LIST, (leaf) => new TaskListView(leaf, this));
    this.registerView(VIEW_TYPE_STATS, (leaf) => new StatsView(leaf, this));
    this.addRibbonIcon("move", "Toggle Dashboard Layout", () => this.toggleLayoutMode());
    this.addCommand({
      id: "open-dashboard",
      name: "Open Dashboard (All-in-One)",
      callback: () => this.activateView(VIEW_TYPE_DASHBOARD)
    });
    this.addCommand({
      id: "open-timeline",
      name: "Open Timeline View",
      callback: () => this.activateView(VIEW_TYPE_TIMELINE)
    });
    this.addCommand({
      id: "open-task-list",
      name: "Open Task List",
      callback: () => this.activateView(VIEW_TYPE_LIST)
    });
    this.addCommand({
      id: "open-stats",
      name: "Open Statistics",
      callback: () => this.activateView(VIEW_TYPE_STATS)
    });
    this.addCommand({
      id: "quick-add-task",
      name: "Quick Add Task",
      callback: () => {
        new QuickAddModal(this.app, this.taskManager).open();
      }
    });
    this.addCommand({
      id: "refresh-dashboard-styles",
      name: "Reload Dashboard Colors/Styles",
      callback: () => this.refreshViews()
    });
    if (!this.settings.hasSeenWelcome) {
      new WelcomeModal(this.app).open();
      this.settings.hasSeenWelcome = true;
      await this.saveSettings();
    }
    this.addSettingTab(new SettingsTab(this.app, this));
  }
  toggleLayoutMode() {
    const viewTypes = [VIEW_TYPE_DASHBOARD, VIEW_TYPE_TIMELINE, VIEW_TYPE_LIST, VIEW_TYPE_STATS];
    let anyUnlocked = false;
    viewTypes.forEach((type) => {
      const leaves = this.app.workspace.getLeavesOfType(type);
      leaves.forEach((leaf) => {
        const tabContainer = leaf.view.containerEl.closest(".workspace-tabs");
        if (tabContainer) {
          if (tabContainer.classList.contains("semester-hide-tabs")) {
            tabContainer.classList.remove("semester-hide-tabs");
            anyUnlocked = true;
          } else {
            tabContainer.classList.add("semester-hide-tabs");
          }
        }
      });
    });
    new import_obsidian13.Notice(anyUnlocked ? "Dashboard Layout: Unlocked \u{1F513}" : "Dashboard Layout: Locked \u{1F512}");
  }
  async activateView(viewType) {
    const leaf = this.app.workspace.getLeaf(true);
    await leaf.setViewState({ type: viewType, active: true });
    this.app.workspace.revealLeaf(leaf);
    setTimeout(() => {
      const tabContainer = leaf.view.containerEl.closest(".workspace-tabs");
      if (tabContainer)
        tabContainer.classList.add("semester-hide-tabs");
    }, 100);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.taskManager.loadTasks();
  }
  refreshViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_DASHBOARD);
    leaves.forEach((leaf) => {
      const view = leaf.view;
      const isDashboard = typeof (view == null ? void 0 : view.getViewType) === "function" && view.getViewType() === VIEW_TYPE_DASHBOARD;
      const canRefresh = typeof (view == null ? void 0 : view.refreshFromSettings) === "function";
      if (isDashboard && canRefresh) {
        view.refreshFromSettings();
      }
    });
  }
};
