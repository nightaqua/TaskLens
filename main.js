/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SemesterDashboardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// services/TaskManager.ts
var import_obsidian = require("obsidian");

// models/Task.ts
function getTaskStatus(task) {
  if (task.completed) return "completed" /* Completed */;
  if (task.dueDate) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const due = new Date(task.dueDate);
    due.setHours(0, 0, 0, 0);
    if (due < today) return "overdue" /* Overdue */;
    const diffTime = due.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    if (diffDays <= 3 && diffDays >= 0) return "urgent" /* Urgent */;
    return "upcoming_week" /* UpcomingWeek */;
  }
  return "no_date" /* NoDate */;
}

// services/TaskManager.ts
var TaskManager = class extends import_obsidian.Events {
  constructor(parser, app) {
    super();
    this.parser = parser;
    this.app = app;
    this.tasks = [];
    this.filteredTasks = [];
    this.currentStatusFilter = "open" /* Open */;
    this.currentCourseFilter = null;
    this.currentSortBy = "due-date" /* DueDate */;
  }
  async loadTasks() {
    this.tasks = await this.parser.findAllTasks();
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  // ... inside TaskManager class ...
  /**
   * Delete a task from its file
   */
  async deleteTask(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber] && lines[task.lineNumber].includes(task.title)) {
        lines.splice(task.lineNumber, 1);
        await this.app.vault.modify(file, lines.join("\n"));
        await this.refreshFileTask(task.filePath);
      } else {
        console.warn("Task line mismatch, skipping delete to prevent data loss.");
      }
    }
  }
  /**
   * Update a task's title and/or due date
   */
  async updateTask(task, newTitle, newDate) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber]) {
        const originalLine = lines[task.lineNumber];
        const match = originalLine.match(/^(\s*-\s\[.\]\s)(.*)$/);
        if (match) {
          const prefix = match[1];
          let newLine = `${prefix}${newTitle}`;
          if (newDate) {
            const dateStr = this.formatDate(newDate);
            newLine += ` [due:: ${dateStr}]`;
          }
          lines[task.lineNumber] = newLine;
          await this.app.vault.modify(file, lines.join("\n"));
          await this.refreshFileTask(task.filePath);
        }
      }
    }
  }
  async refreshFileTask(filePath) {
    const fileTasks = await this.parser.getTasksFromFile(filePath);
    this.tasks = this.tasks.filter((t) => t.filePath !== filePath);
    this.tasks.push(...fileTasks);
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  getAllTasks() {
    return [...this.tasks];
  }
  getFilteredTasks() {
    return [...this.filteredTasks];
  }
  getStatistics() {
    const total = this.tasks.length;
    const completed = this.tasks.filter((t) => t.completed).length;
    const overdue = this.tasks.filter((t) => getTaskStatus(t) === "overdue" /* Overdue */).length;
    const upcoming = this.tasks.filter((t) => getTaskStatus(t) === "upcoming_week" /* UpcomingWeek */).length;
    const urgent = this.tasks.filter((t) => getTaskStatus(t) === "urgent" /* Urgent */).length;
    const courses = new Set(this.tasks.map((t) => t.fileName)).size;
    return { total, completed, overdue, upcoming, urgent, courses };
  }
  getCourseNames() {
    return Array.from(new Set(this.tasks.map((t) => t.fileName))).sort();
  }
  setStatusFilter(status) {
    this.currentStatusFilter = status;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  setCourseFilter(course) {
    this.currentCourseFilter = course;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  setSortBy(sortBy) {
    this.currentSortBy = sortBy;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated");
  }
  getCurrentFilters() {
    return {
      status: this.currentStatusFilter,
      course: this.currentCourseFilter,
      sortBy: this.currentSortBy
    };
  }
  async addTask(title, date, filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      let content = await this.app.vault.read(file);
      let taskLine = `
- [ ] ${title}`;
      if (date) {
        const dateStr = this.formatDate(date);
        taskLine += ` [due:: ${dateStr}]`;
      }
      await this.app.vault.modify(file, content + taskLine);
      await this.refreshFileTask(filePath);
    }
  }
  formatDate(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  applyFiltersAndSort() {
    this.filteredTasks = this.tasks.filter((task) => {
      if (this.currentStatusFilter !== "all" /* All */) {
        if (this.currentStatusFilter === "open" /* Open */) {
          return !task.completed;
        }
        if (this.currentStatusFilter === "completed" /* Completed */ && !task.completed) return false;
      }
      if (this.currentCourseFilter && task.fileName !== this.currentCourseFilter) return false;
      return true;
    });
    this.filteredTasks.sort((a, b) => {
      const weightA = this.getStatusWeight(a);
      const weightB = this.getStatusWeight(b);
      if (weightA !== weightB) return weightA - weightB;
      if (a.dueDate && b.dueDate) return a.dueDate.getTime() - b.dueDate.getTime();
      if (a.dueDate) return -1;
      if (b.dueDate) return 1;
      return 0;
    });
  }
  getStatusWeight(task) {
    const status = getTaskStatus(task);
    switch (status) {
      case "overdue" /* Overdue */:
        return 1;
      case "urgent" /* Urgent */:
        return 2;
      case "upcoming_week" /* UpcomingWeek */:
        return 3;
      case "no_date" /* NoDate */:
        return 4;
      case "completed" /* Completed */:
        return 5;
      default:
        return 3;
    }
  }
};

// services/TaskParser.ts
var import_obsidian2 = require("obsidian");
var TaskParser = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * RENAMED: Matches TaskManager.loadTasks()
   */
  async findAllTasks() {
    const tasks = [];
    const filesToScan = this.getFilesToScan();
    for (const file of filesToScan) {
      const fileTasks = await this.parseTasksFromFile(file);
      tasks.push(...fileTasks);
    }
    return tasks;
  }
  /**
   * RENAMED: Matches TaskManager.refreshFileTask()
   */
  async getTasksFromFile(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian2.TFile) {
      return this.parseTasksFromFile(file);
    }
    return [];
  }
  // --- Private Helpers ---
  getFilesToScan() {
    const allMarkdownFiles = this.app.vault.getMarkdownFiles();
    if (this.settings.scanFolders.length === 0) {
      return allMarkdownFiles;
    }
    return allMarkdownFiles.filter((file) => {
      return this.settings.scanFolders.some((folder) => {
        var _a;
        const normalizedFolder = folder.replace(/^\/|\/$/g, "");
        const filePath = file.path;
        if (this.settings.scanRecursively) {
          return filePath.startsWith(normalizedFolder);
        } else {
          const fileFolder = ((_a = file.parent) == null ? void 0 : _a.path) || "";
          return fileFolder === normalizedFolder;
        }
      });
    });
  }
  async parseTasksFromFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const cache = this.app.metadataCache.getFileCache(file);
    const courseName = this.getCourseName(file, cache);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const taskMatch = line.match(/^(\s*)-\s\[([ xX])\]\s(.+)$/);
      if (taskMatch) {
        const completed = taskMatch[2].toLowerCase() === "x";
        const taskText = taskMatch[3];
        const { title, startDate, dueDate } = this.parseTaskMetadata(taskText);
        const task = {
          id: `${file.path}:${i}`,
          title,
          completed,
          filePath: file.path,
          fileName: courseName,
          lineNumber: i,
          startDate,
          dueDate,
          originalText: line
        };
        tasks.push(task);
      }
    }
    return tasks;
  }
  getCourseName(file, cache) {
    var _a;
    switch (this.settings.courseDetection) {
      case "per-file":
        return file.basename;
      case "per-folder":
        return ((_a = file.parent) == null ? void 0 : _a.name) || file.basename;
      case "frontmatter":
        if (cache == null ? void 0 : cache.frontmatter) {
          const val = cache.frontmatter[this.settings.courseFrontmatterKey];
          if (val) return String(val);
        }
        return file.basename;
      default:
        return file.basename;
    }
  }
  parseTaskMetadata(taskText) {
    let title = taskText;
    let startDate;
    let dueDate;
    const startRegex = /\[?\(?start::\s*(\d{4}-\d{2}-\d{2})[\]\)]?/gi;
    const startMatch = startRegex.exec(taskText);
    if (startMatch) {
      startDate = new Date(startMatch[1]);
      title = title.replace(startRegex, "");
    }
    const dueRegex = /\[?\(?due::\s*(\d{4}-\d{2}-\d{2})[\]\)]?/gi;
    const dueMatch = dueRegex.exec(taskText);
    if (dueMatch) {
      dueDate = new Date(dueMatch[1]);
      title = title.replace(dueRegex, "");
    }
    if (!dueDate) {
      const emojiMatch = taskText.match(/ðŸ“…\s*(\d{4}-\d{2}-\d{2})/);
      if (emojiMatch) {
        dueDate = new Date(emojiMatch[1]);
        title = title.replace(/ðŸ“…\s*\d{4}-\d{2}-\d{2}\s*/g, "");
      }
    }
    title = title.replace(/\s+/g, " ").trim();
    return { title, startDate, dueDate };
  }
};

// settings/Settings.ts
var DEFAULT_SETTINGS = {
  // Scanning Defaults
  scanFolders: [],
  scanRecursively: true,
  courseDetection: "per-file",
  courseFrontmatterKey: "course",
  startDateKey: "start",
  dueDateKey: "due",
  // Visual Defaults
  colorScheme: "inherit",
  colorMode: "status",
  colors: {
    overdue: "#e63946",
    urgent: "#fb8500",
    active: "#2a9d8f",
    completed: "#457b9d"
  }
};

// settings/SettingsTab.ts
var import_obsidian3 = require("obsidian");
var SettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("semester-dashboard-settings");
    containerEl.createEl("h2", { text: "Semester Dashboard Settings" });
    const scanDetails = containerEl.createEl("details");
    scanDetails.open = true;
    scanDetails.createEl("summary", { text: "Vault Scanning" });
    new import_obsidian3.Setting(scanDetails).setName("Scan folders").setDesc("Folders to scan (one per line).").addTextArea((text) => {
      text.setPlaceholder("Uni/Courses").setValue(this.plugin.settings.scanFolders.join("\n")).onChange(async (value) => {
        this.plugin.settings.scanFolders = value.split("\n").map((s) => s.trim()).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
    });
    const parserDetails = containerEl.createEl("details");
    parserDetails.createEl("summary", { text: "Task Parsing" });
    new import_obsidian3.Setting(parserDetails).setName("Start Key").addText((t) => t.setValue(this.plugin.settings.startDateKey).onChange(async (v) => {
      this.plugin.settings.startDateKey = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(parserDetails).setName("Due Key").addText((t) => t.setValue(this.plugin.settings.dueDateKey).onChange(async (v) => {
      this.plugin.settings.dueDateKey = v;
      await this.plugin.saveSettings();
    }));
    const uiDetails = containerEl.createEl("details");
    uiDetails.createEl("summary", { text: "Appearance & Colors" });
    new import_obsidian3.Setting(uiDetails).setName("Color Mode").addDropdown((d) => d.addOption("status", "By Status").addOption("course", "By Course (Simple)").setValue(this.plugin.settings.colorMode).onChange(async (v) => {
      this.plugin.settings.colorMode = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(uiDetails).setName("Overdue Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.overdue).onChange(async (v) => {
      this.plugin.settings.colors.overdue = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
    new import_obsidian3.Setting(uiDetails).setName("Urgent Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.urgent).onChange(async (v) => {
      this.plugin.settings.colors.urgent = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
    new import_obsidian3.Setting(uiDetails).setName("Active Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.active).onChange(async (v) => {
      this.plugin.settings.colors.active = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
    new import_obsidian3.Setting(uiDetails).setName("Completed Color").addColorPicker((c) => c.setValue(this.plugin.settings.colors.completed).onChange(async (v) => {
      this.plugin.settings.colors.completed = v;
      await this.plugin.saveSettings();
      this.plugin.refreshViews();
    }));
  }
};

// views/DashboardView.ts
var import_obsidian6 = require("obsidian");

// views/TimelineComponent.ts
var TimelineComponent = class {
  constructor(container, tasks, daysToShow = 7) {
    // Drag state
    this.isDragging = false;
    this.startX = 0;
    this.scrollLeft = 0;
    // The actual horizontally scrollable element (created in render)
    this.scrollContainer = null;
    this.todayColumnIndex = -1;
    this.container = container;
    this.tasks = tasks.filter((t) => t.dueDate);
    this.daysToShow = daysToShow;
  }
  render() {
    this.container.empty();
    this.container.addClass("timeline-wrapper");
    this.todayColumnIndex = -1;
    const validTasks = this.tasks.filter((t) => t.dueDate instanceof Date && !isNaN(t.dueDate.getTime()));
    if (validTasks.length === 0) {
      const scrollContainer = this.container.createDiv("timeline-container");
      const empty = scrollContainer.createDiv("dashboard-empty-state");
      empty.createEl("p", { text: "No dated tasks to display." });
      return;
    }
    this.createNavigationOverlay("left");
    this.createNavigationOverlay("right");
    this.scrollContainer = this.container.createDiv("timeline-container");
    this.setupEventListeners(this.scrollContainer);
    const dates = validTasks.map((t) => [t.startDate, t.dueDate]).flat().filter((d) => !!d).sort((a, b) => a.getTime() - b.getTime());
    if (dates.length === 0) return;
    const minDate = new Date(dates[0]);
    minDate.setDate(minDate.getDate() - 14);
    const maxDate = new Date(dates[dates.length - 1]);
    maxDate.setDate(maxDate.getDate() + 14);
    const allDays = [];
    const current = new Date(minDate);
    while (current <= maxDate) {
      allDays.push(new Date(current));
      current.setDate(current.getDate() + 1);
    }
    const grid = this.scrollContainer.createDiv("timeline-grid");
    const colWidthPercent = 100 / this.daysToShow;
    grid.style.gridTemplateColumns = `repeat(${allDays.length}, ${colWidthPercent}%)`;
    const borderColor = "rgba(200, 200, 200, 0.15)";
    grid.style.backgroundImage = `linear-gradient(to right, transparent 0%, transparent calc(100% - 1px), ${borderColor} 100%)`;
    grid.style.backgroundSize = `${colWidthPercent}% 100%`;
    const todayStr = (/* @__PURE__ */ new Date()).toDateString();
    let todayColumn = -1;
    allDays.forEach((day, index) => {
      const isWeekend = day.getDay() === 0 || day.getDay() === 6;
      const cell = grid.createDiv("timeline-header-cell");
      if (isWeekend) cell.addClass("weekend");
      const dayName = day.toLocaleDateString(void 0, { weekday: "short" });
      const dayNum = day.getDate();
      const month = day.toLocaleDateString(void 0, { month: "short" });
      const label = dayNum === 1 || index === 0 ? `${month} ${dayNum}` : `${dayName} ${dayNum}`;
      cell.setText(label);
      cell.style.gridColumn = `${index + 1}`;
      cell.style.gridRow = "1";
      if (day.toDateString() === todayStr) {
        const marker = grid.createDiv("timeline-today-marker");
        marker.style.gridColumn = `${index + 1}`;
        todayColumn = index;
        this.todayColumnIndex = index;
      }
    });
    validTasks.forEach((task, index) => {
      const taskStart = task.startDate ? task.startDate : task.dueDate;
      const taskEnd = task.dueDate;
      const startIndex = this.getDayDiff(minDate, taskStart) + 1;
      const endIndex = this.getDayDiff(minDate, taskEnd) + 1;
      const visualStart = Math.min(startIndex, endIndex);
      const visualEnd = Math.max(startIndex, endIndex);
      const bar = grid.createDiv("timeline-task-bar");
      bar.setText(task.title);
      const status = getTaskStatus(task);
      if (status === "overdue" /* Overdue */) bar.addClass("status-overdue");
      else if (status === "urgent" /* Urgent */) bar.addClass("status-urgent");
      else if (status === "completed" /* Completed */) bar.addClass("status-completed");
      else bar.addClass("status-active");
      bar.style.gridColumn = `${visualStart} / ${visualEnd + 1}`;
      bar.style.gridRow = `${index + 2}`;
      const dateStr = task.dueDate ? task.dueDate.toLocaleDateString() : "No date";
      bar.setAttribute("title", `${task.title}
${task.fileName}
Due: ${dateStr}`);
    });
    this.scrollToToday();
  }
  scrollToToday() {
    if (this.todayColumnIndex !== -1 && this.scrollContainer) {
      setTimeout(() => {
        if (!this.scrollContainer) return;
        const containerWidth = this.scrollContainer.clientWidth;
        const columnWidth = containerWidth / this.daysToShow;
        const scrollPos = this.todayColumnIndex * columnWidth - containerWidth / 2 + columnWidth / 2;
        this.scrollContainer.scrollTo({ left: scrollPos, behavior: "smooth" });
      }, 100);
    }
  }
  createNavigationOverlay(direction) {
    const overlay = this.container.createDiv(`timeline-nav-overlay nav-${direction}`);
    const arrow = overlay.createDiv("nav-arrow");
    arrow.setText(direction === "left" ? "\u2039" : "\u203A");
    overlay.addEventListener("click", (e) => {
      var _a;
      e.stopPropagation();
      const scroller = (_a = this.scrollContainer) != null ? _a : this.container.querySelector(".timeline-container");
      if (!scroller) return;
      const amount = scroller.clientWidth / 2;
      scroller.scrollBy({ left: direction === "left" ? -amount : amount, behavior: "smooth" });
    });
  }
  setupEventListeners(target) {
    target.addEventListener("mousedown", (e) => {
      this.isDragging = true;
      target.addClass("is-dragging");
      this.startX = e.pageX - target.offsetLeft;
      this.scrollLeft = target.scrollLeft;
    });
    target.addEventListener("mouseleave", () => {
      this.isDragging = false;
      target.removeClass("is-dragging");
    });
    target.addEventListener("mouseup", () => {
      this.isDragging = false;
      target.removeClass("is-dragging");
    });
    target.addEventListener("mousemove", (e) => {
      if (!this.isDragging) return;
      e.preventDefault();
      const x = e.pageX - target.offsetLeft;
      const walk = (x - this.startX) * 1.5;
      target.scrollLeft = this.scrollLeft - walk;
    });
  }
  scroll(direction) {
    var _a;
    const scroller = (_a = this.scrollContainer) != null ? _a : this.container;
    const scrollAmount = scroller.clientWidth / 2;
    const newPos = direction === "left" ? scroller.scrollLeft - scrollAmount : scroller.scrollLeft + scrollAmount;
    scroller.scrollTo({ left: newPos, behavior: "smooth" });
  }
  getDayDiff(start, end) {
    const oneDay = 1e3 * 60 * 60 * 24;
    const diff = end.getTime() - start.getTime();
    return Math.floor(diff / oneDay);
  }
};

// views/TaskListComponent.ts
var import_obsidian4 = require("obsidian");
var TaskListComponent = class {
  // We need callbacks for the new actions
  constructor(container, app, callbacks) {
    this.container = container;
    this.app = app;
    this.callbacks = callbacks;
  }
  render(tasks, groupBy = "none") {
    this.container.empty();
    if (tasks.length === 0) {
      const empty = this.container.createDiv("dashboard-empty-state");
      empty.createEl("p", { text: "No tasks found." });
      return;
    }
    const listContainer = this.container.createDiv("dashboard-task-list");
    tasks.forEach((task) => {
      this.renderTaskItem(listContainer, task);
    });
  }
  renderTaskItem(container, task) {
    const status = getTaskStatus(task);
    let statusClass = "status-active";
    if (status === "overdue" /* Overdue */) statusClass = "status-overdue";
    if (status === "urgent" /* Urgent */) statusClass = "status-urgent";
    if (status === "completed" /* Completed */) statusClass = "status-completed";
    const taskEl = container.createDiv({ cls: ["task-item", statusClass] });
    const checkbox = taskEl.createEl("input", { type: "checkbox", cls: "task-checkbox" });
    checkbox.checked = task.completed;
    checkbox.addEventListener("change", () => this.callbacks.onToggle(task));
    const content = taskEl.createDiv("task-content");
    const viewMode = content.createDiv("task-view-mode");
    const titleEl = viewMode.createDiv("task-title");
    titleEl.setText(task.title);
    const meta = viewMode.createDiv("task-meta");
    meta.createSpan("task-course").setText(task.fileName);
    if (task.dueDate) {
      const d = task.dueDate.getDate().toString().padStart(2, "0");
      const m = (task.dueDate.getMonth() + 1).toString().padStart(2, "0");
      meta.createSpan("task-date").setText(`Due: ${d}-${m}-${task.dueDate.getFullYear()}`);
    }
    titleEl.addEventListener("click", () => this.openTaskInEditor(task));
    const actions = taskEl.createDiv("task-actions");
    const editBtn = actions.createEl("button", { cls: "task-action-btn" });
    (0, import_obsidian4.setIcon)(editBtn, "pencil");
    editBtn.setAttribute("aria-label", "Edit Task");
    const deleteBtn = actions.createEl("button", { cls: "task-action-btn btn-danger" });
    (0, import_obsidian4.setIcon)(deleteBtn, "trash-2");
    deleteBtn.setAttribute("aria-label", "Delete Task");
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.callbacks.onDelete(task);
    });
    editBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      viewMode.hide();
      actions.hide();
      const editMode = content.createDiv("task-edit-mode");
      const titleInput = editMode.createEl("input", {
        type: "text",
        value: task.title,
        cls: "task-edit-input"
      });
      const dateInput = editMode.createEl("input", {
        type: "date",
        cls: "task-edit-date"
      });
      if (task.dueDate) {
        const y = task.dueDate.getFullYear();
        const m = String(task.dueDate.getMonth() + 1).padStart(2, "0");
        const d = String(task.dueDate.getDate()).padStart(2, "0");
        dateInput.value = `${y}-${m}-${d}`;
      }
      const saveBtn = editMode.createEl("button", { cls: "task-save-btn", text: "Save" });
      const cancelBtn = editMode.createEl("button", { cls: "task-cancel-btn", text: "Cancel" });
      const save = () => {
        const newTitle = titleInput.value.trim();
        if (newTitle) {
          const newDate = dateInput.value ? new Date(dateInput.value) : null;
          this.callbacks.onEdit(task, newTitle, newDate);
        }
      };
      const cancel = () => {
        editMode.remove();
        viewMode.show();
        actions.show();
      };
      saveBtn.addEventListener("click", save);
      cancelBtn.addEventListener("click", cancel);
      titleInput.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") save();
        if (evt.key === "Escape") cancel();
      });
      titleInput.focus();
    });
  }
  async openTaskInEditor(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      if (view) {
        view.editor.setCursor({ line: task.lineNumber, ch: 0 });
        view.editor.scrollIntoView({ from: { line: task.lineNumber, ch: 0 }, to: { line: task.lineNumber, ch: 0 } }, true);
      }
    }
  }
};

// views/HeaderComponent.ts
var import_obsidian5 = require("obsidian");
var HeaderComponent = class {
  // NEW PROPERTY
  constructor(container, initialState, defaultTitle, callbacks) {
    this.headerEl = null;
    this.sidebarHandleEl = null;
    this.isSaving = false;
    this.container = container;
    this.defaultTitle = defaultTitle;
    this.title = initialState.title || defaultTitle;
    this.isCollapsed = initialState.isCollapsed || false;
    this.onStateChange = callbacks.onStateChange;
    this.onRefresh = callbacks.onRefresh;
    this.onSettings = callbacks.onSettings || null;
    this.onAdd = callbacks.onAdd || null;
  }
  render() {
    this.renderSidebarHandle();
    this.renderHeader();
    this.updateVisibility();
  }
  renderSidebarHandle() {
    if (this.sidebarHandleEl) this.sidebarHandleEl.remove();
    this.sidebarHandleEl = this.container.createDiv("dashboard-sidebar-handle");
    (0, import_obsidian5.setIcon)(this.sidebarHandleEl, "panel-left-open");
    this.sidebarHandleEl.addEventListener("click", () => {
      this.isCollapsed = false;
      this.updateVisibility();
      this.onStateChange();
    });
  }
  renderHeader() {
    if (this.headerEl) this.headerEl.remove();
    this.headerEl = this.container.createDiv("dashboard-header");
    const leftGroup = this.headerEl.createDiv("header-actions-left");
    if (this.onSettings) {
      const settingsBtn = leftGroup.createEl("button", { cls: "header-icon-btn" });
      (0, import_obsidian5.setIcon)(settingsBtn, "settings");
      settingsBtn.addEventListener("click", () => this.onSettings());
    }
    const titleWrapper = this.headerEl.createDiv("dashboard-title-wrapper");
    const titleEl = titleWrapper.createEl("h2", { text: this.title });
    const editIcon = titleWrapper.createDiv("edit-title-icon");
    (0, import_obsidian5.setIcon)(editIcon, "pencil");
    titleWrapper.addEventListener("click", () => this.enterEditMode(titleWrapper));
    const rightGroup = this.headerEl.createDiv("header-actions-right");
    if (this.onAdd) {
      const addBtn = rightGroup.createEl("button", { cls: "header-icon-btn" });
      (0, import_obsidian5.setIcon)(addBtn, "plus");
      addBtn.setAttribute("aria-label", "Quick Add Task");
      addBtn.addEventListener("click", () => this.onAdd());
    }
    const refreshBtn = rightGroup.createEl("button", { cls: "dashboard-refresh-btn header-icon-btn" });
    (0, import_obsidian5.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.addEventListener("click", () => {
      refreshBtn.addClass("is-rotating");
      this.onRefresh();
      setTimeout(() => refreshBtn.removeClass("is-rotating"), 1e3);
    });
    const hideBtn = rightGroup.createEl("button", { cls: "header-icon-btn" });
    (0, import_obsidian5.setIcon)(hideBtn, "panel-top-close");
    hideBtn.addEventListener("click", () => {
      this.isCollapsed = true;
      this.updateVisibility();
      this.onStateChange();
    });
  }
  enterEditMode(wrapper) {
    wrapper.empty();
    const input = wrapper.createEl("input", { type: "text", value: this.title, cls: "dashboard-title-input" });
    input.focus();
    input.select();
    this.isSaving = false;
    const save = () => {
      if (this.isSaving) return;
      this.isSaving = true;
      const newVal = input.value.trim();
      this.title = newVal.length > 0 ? newVal : this.defaultTitle;
      this.onStateChange();
    };
    input.addEventListener("blur", save);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
        save();
      }
    });
    input.addEventListener("keypress", (e) => e.stopPropagation());
  }
  updateVisibility() {
    var _a, _b, _c, _d;
    if (this.isCollapsed) {
      (_a = this.headerEl) == null ? void 0 : _a.addClass("is-collapsed");
      (_b = this.sidebarHandleEl) == null ? void 0 : _b.removeClass("is-hidden");
    } else {
      (_c = this.headerEl) == null ? void 0 : _c.removeClass("is-collapsed");
      (_d = this.sidebarHandleEl) == null ? void 0 : _d.addClass("is-hidden");
    }
  }
  getState() {
    return { title: this.title, isCollapsed: this.isCollapsed };
  }
};

// views/DashboardView.ts
var VIEW_TYPE_DASHBOARD = "semester-dashboard-view";
var DashboardView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.timelineComponent = null;
    // Ref to access scrollToToday
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    // UI State
    this.showControls = true;
    this.showTimeline = true;
    this.showList = true;
    this.showStats = true;
    this.timelineDaysToShow = 7;
    this.taskManager = this.plugin.taskManager;
    this.taskManager.on("tasks-updated", () => this.render());
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file.path.endsWith(".md")) this.taskManager.refreshFileTask(file.path);
      })
    );
    this.taskManager.setStatusFilter("open" /* Open */);
  }
  getViewType() {
    return VIEW_TYPE_DASHBOARD;
  }
  getDisplayText() {
    return "Personal Dashboard";
  }
  getIcon() {
    return "layout-dashboard";
  }
  // --- Persistence Logic ---
  async setState(state, result) {
    var _a, _b, _c, _d, _e;
    if (state) {
      this.showControls = (_a = state.showControls) != null ? _a : this.showControls;
      this.showTimeline = (_b = state.showTimeline) != null ? _b : this.showTimeline;
      this.showList = (_c = state.showList) != null ? _c : this.showList;
      this.showStats = (_d = state.showStats) != null ? _d : this.showStats;
      this.timelineDaysToShow = (_e = state.timelineDaysToShow) != null ? _e : this.timelineDaysToShow;
      if (state.statusFilter) this.taskManager.setStatusFilter(state.statusFilter);
      if (state.courseFilter) this.taskManager.setCourseFilter(state.courseFilter);
      if (state.headerState) this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    const filters = this.taskManager.getCurrentFilters();
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return {
      showControls: this.showControls,
      showTimeline: this.showTimeline,
      showList: this.showList,
      showStats: this.showStats,
      timelineDaysToShow: this.timelineDaysToShow,
      statusFilter: filters.status,
      courseFilter: filters.course,
      headerState: this.headerState
    };
  }
  // -------------------------
  async onOpen() {
    const parent = this.containerEl.closest(".workspace-leaf-content");
    if (parent) parent.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer) this.tabContainer.classList.add("semester-hide-tabs");
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.applyColorTheme();
    await this.taskManager.loadTasks();
    this.render();
  }
  // 3. Remove class on close
  async onClose() {
    if (this.tabContainer) this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Personal Dashboard",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.taskManager.loadTasks();
          if (this.timelineComponent) {
            this.timelineComponent.scrollToToday();
          }
        },
        onSettings: () => {
          this.showControls = !this.showControls;
          this.app.workspace.requestSaveLayout();
          this.render();
        }
      }
    );
    this.headerComponent.render();
    this.renderControls();
    const layoutOrder = ["stats", "timeline", "list"];
    layoutOrder.forEach((component) => {
      if (component === "stats" && this.showStats) this.renderStatistics();
      if (component === "timeline" && this.showTimeline) this.renderTimeline();
      if (component === "list" && this.showList) this.renderTaskList();
    });
  }
  renderControls() {
    if (!this.showControls) return;
    const controls = this.contentEl.createDiv("dashboard-controls");
    const filtersDiv = controls.createDiv("filters-wrapper");
    filtersDiv.style.display = "flex";
    filtersDiv.style.gap = "12px";
    filtersDiv.style.flexWrap = "wrap";
    const statusGroup = filtersDiv.createDiv("control-group");
    statusGroup.createEl("label", { text: "Show:" });
    const statusSelect = statusGroup.createEl("select");
    const statusOptions = [
      { value: "open" /* Open */, label: "Active" },
      // Green
      { value: "all" /* All */, label: "All Tasks" },
      { value: "completed" /* Completed */, label: "Completed" }
    ];
    statusOptions.forEach((opt) => {
      const option = statusSelect.createEl("option", { value: opt.value, text: opt.label });
      if (opt.value === this.taskManager.getCurrentFilters().status) option.selected = true;
    });
    statusSelect.addEventListener("change", () => {
      this.taskManager.setStatusFilter(statusSelect.value);
    });
    const courseGroup = filtersDiv.createDiv("control-group");
    courseGroup.createEl("label", { text: "Topic:" });
    const courseSelect = courseGroup.createEl("select");
    courseSelect.createEl("option", { value: "", text: "All Topics" });
    this.taskManager.getCourseNames().forEach((course) => {
      const option = courseSelect.createEl("option", { value: course, text: course });
      if (course === this.taskManager.getCurrentFilters().course) option.selected = true;
    });
    courseSelect.addEventListener("change", () => {
      this.taskManager.setCourseFilter(courseSelect.value || null);
    });
    const actionsDiv = controls.createDiv("actions-wrapper");
    actionsDiv.style.display = "flex";
    actionsDiv.style.gap = "12px";
    actionsDiv.style.alignItems = "center";
    const toggleTimeline = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showTimeline ? "is-active" : ""}`,
      text: "Timeline"
    });
    toggleTimeline.addEventListener("click", () => {
      this.showTimeline = !this.showTimeline;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
    const toggleList = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showList ? "is-active" : ""}`,
      text: "List"
    });
    toggleList.addEventListener("click", () => {
      this.showList = !this.showList;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
    const statsBtn = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showStats ? "is-active" : ""}`,
      text: "Stats"
    });
    statsBtn.addEventListener("click", () => {
      this.showStats = !this.showStats;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
  }
  renderStatistics() {
    const stats = this.taskManager.getStatistics();
    const allTasks = this.taskManager.getAllTasks();
    const activeCount = allTasks.filter((t) => !t.completed).length;
    const container = this.contentEl.createDiv("dashboard-stats");
    const statCards = [
      { label: "Total", value: stats.total, cls: "stat-total" },
      // Purple
      { label: "Active", value: activeCount, cls: "stat-active" },
      // Green
      { label: "Urgent", value: stats.urgent, cls: "stat-urgent" },
      // Orange
      { label: "Overdue", value: stats.overdue, cls: "stat-overdue" },
      // Red
      { label: "Completed", value: stats.completed, cls: "stat-completed" }
      // Blue
    ];
    statCards.forEach((stat) => {
      const card = container.createDiv({ cls: ["stat-card", stat.cls] });
      card.createDiv("stat-value").setText(String(stat.value));
      card.createDiv("stat-label").setText(stat.label);
    });
  }
  renderTaskList() {
    const container = this.contentEl.createDiv();
    const list = new TaskListComponent(container, this.app, {
      onToggle: (t) => this.toggleTaskCompletion(t),
      onEdit: async (t, newTitle, newDate) => {
        await this.taskManager.updateTask(t, newTitle, newDate);
      },
      onDelete: async (t) => {
        await this.taskManager.deleteTask(t);
      }
    });
    list.render(this.taskManager.getFilteredTasks());
  }
  applyColorTheme() {
    const cols = this.plugin.settings.colors;
    this.contentEl.style.setProperty("--color-red", cols.overdue);
    this.contentEl.style.setProperty("--color-orange", cols.urgent);
    this.contentEl.style.setProperty("--color-green", cols.active);
    this.contentEl.style.setProperty("--color-blue", cols.completed);
    this.contentEl.style.setProperty("--color-purple", "#7209b7");
  }
  refreshFromSettings() {
    if (!this.contentEl.isConnected) return;
    this.applyColorTheme();
    this.render();
    this.app.workspace.requestSaveLayout();
  }
  renderTimeline() {
    const container = this.contentEl.createDiv("dashboard-timeline-view");
    const controls = container.createDiv("timeline-controls");
    const zoomControls = controls.createDiv("zoom-controls");
    zoomControls.createSpan({ text: "Zoom: " });
    const zoomOut = zoomControls.createEl("button", { text: "-", cls: "view-toggle-btn" });
    zoomOut.addEventListener("click", () => {
      this.timelineDaysToShow = Math.min(30, this.timelineDaysToShow + 1);
      this.render();
    });
    zoomControls.createSpan({ text: ` ${this.timelineDaysToShow} Days ` });
    const zoomIn = zoomControls.createEl("button", { text: "+", cls: "view-toggle-btn" });
    zoomIn.addEventListener("click", () => {
      this.timelineDaysToShow = Math.max(3, this.timelineDaysToShow - 1);
      this.render();
    });
    const navControls = controls.createDiv("nav-controls");
    const scrollLeft = navControls.createEl("button", { cls: "view-toggle-btn" });
    (0, import_obsidian6.setIcon)(scrollLeft, "chevron-left");
    const scrollRight = navControls.createEl("button", { cls: "view-toggle-btn" });
    (0, import_obsidian6.setIcon)(scrollRight, "chevron-right");
    this.timelineComponent = new TimelineComponent(container, this.taskManager.getFilteredTasks(), this.timelineDaysToShow);
    this.timelineComponent.render();
    scrollLeft.addEventListener("click", () => {
      var _a;
      return (_a = this.timelineComponent) == null ? void 0 : _a.scroll("left");
    });
    scrollRight.addEventListener("click", () => {
      var _a;
      return (_a = this.timelineComponent) == null ? void 0 : _a.scroll("right");
    });
  }
  // ... Helpers (toggleTaskCompletion, openTaskInEditor) remain same ...
  async toggleTaskCompletion(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber]) {
        lines[task.lineNumber] = lines[task.lineNumber].includes("[x]") ? lines[task.lineNumber].replace("[x]", "[ ]") : lines[task.lineNumber].replace("[ ]", "[x]");
        await this.app.vault.modify(file, lines.join("\n"));
      }
    }
  }
  async openTaskInEditor(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (view) {
        view.editor.setCursor({ line: task.lineNumber, ch: 0 });
        view.editor.scrollIntoView({ from: { line: task.lineNumber, ch: 0 }, to: { line: task.lineNumber, ch: 0 } }, true);
      }
    }
  }
};

// views/TimelineView.ts
var import_obsidian7 = require("obsidian");
var VIEW_TYPE_TIMELINE = "semester-timeline-view";
var TimelineView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.plugin.taskManager.on("tasks-updated", () => this.render());
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "Timeline";
  }
  getIcon() {
    return "calendar-range";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer) this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.contentEl.addClass("is-single-view");
    await this.plugin.taskManager.loadTasks();
    this.render();
  }
  async onClose() {
    if (this.tabContainer) this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Timeline",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        }
      }
    );
    this.headerComponent.render();
    const timeline = new TimelineComponent(this.contentEl, this.plugin.taskManager.getFilteredTasks(), 7);
    timeline.render();
  }
};

// views/TaskListView.ts
var import_obsidian9 = require("obsidian");

// modals/QuickAddModal.ts
var import_obsidian8 = require("obsidian");
var QuickAddModal = class extends import_obsidian8.Modal {
  constructor(app, taskManager) {
    super(app);
    this.taskManager = taskManager;
    this.title = "";
    this.date = "";
    this.selectedFile = "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Quick Add Task" });
    new import_obsidian8.Setting(contentEl).setName("Task").addText((text) => text.setPlaceholder("Read Chapter 4...").onChange((value) => this.title = value).inputEl.focus());
    new import_obsidian8.Setting(contentEl).setName("Course (File)").addDropdown((drop) => {
      const tasks = this.taskManager.getAllTasks();
      const knownFiles = tasks.map((t) => t.filePath);
      const uniqueFiles = Array.from(new Set(knownFiles));
      if (uniqueFiles.length > 0) {
        this.selectedFile = uniqueFiles[0];
        uniqueFiles.forEach((path) => {
          var _a;
          const name = ((_a = path.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || path;
          drop.addOption(path, name);
        });
      } else {
        drop.addOption("", "No course files found");
      }
      drop.setValue(this.selectedFile);
      drop.onChange((value) => this.selectedFile = value);
    });
    new import_obsidian8.Setting(contentEl).setName("Due Date").addText((text) => {
      text.inputEl.type = "date";
      text.onChange((value) => this.date = value);
    });
    new import_obsidian8.Setting(contentEl).addButton((btn) => btn.setButtonText("Add Task").setCta().onClick(async () => {
      if (!this.title || !this.selectedFile) return;
      const dateObj = this.date ? new Date(this.date) : null;
      await this.taskManager.addTask(this.title, dateObj, this.selectedFile);
      this.close();
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};

// views/TaskListView.ts
var VIEW_TYPE_LIST = "semester-list-view";
var TaskListView = class extends import_obsidian9.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.headerState = { title: null, isCollapsed: false };
    this.leafRootEl = null;
    this.plugin.taskManager.on("tasks-updated", () => this.render());
  }
  getViewType() {
    return VIEW_TYPE_LIST;
  }
  getDisplayText() {
    return "Task List";
  }
  getIcon() {
    return "list-todo";
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.contentEl.addClass("is-single-view");
    this.render();
  }
  async onClose() {
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) this.headerState = state.headerState;
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) this.headerState = this.headerComponent.getState();
    return { headerState: this.headerState };
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "My Tasks",
      {
        onStateChange: () => {
          this.headerState = this.headerComponent.getState();
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        },
        // NEW: Open Quick Add Modal
        onAdd: () => {
          new QuickAddModal(this.app, this.plugin.taskManager).open();
        }
      }
    );
    this.headerComponent.render();
    const list = new TaskListComponent(this.contentEl, this.app, {
      onToggle: (t) => this.toggleTask(t),
      onEdit: async (t, newTitle, newDate) => {
        await this.plugin.taskManager.updateTask(t, newTitle, newDate);
      },
      onDelete: async (t) => {
        await this.plugin.taskManager.deleteTask(t);
      }
    });
    list.render(this.plugin.taskManager.getFilteredTasks());
  }
  async toggleTask(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber]) {
        lines[task.lineNumber] = lines[task.lineNumber].includes("[x]") ? lines[task.lineNumber].replace("[x]", "[ ]") : lines[task.lineNumber].replace("[ ]", "[x]");
        await this.app.vault.modify(file, lines.join("\n"));
      }
    }
  }
};

// views/StatsView.ts
var import_obsidian10 = require("obsidian");

// views/StatsComponent.ts
var StatsComponent = class {
  constructor(container) {
    this.container = container;
  }
  render(taskManager) {
    this.container.empty();
    const stats = taskManager.getStatistics();
    const tasks = taskManager.getAllTasks();
    const urgentCount = tasks.filter((t) => !t.completed && getTaskStatus(t) === "urgent" /* Urgent */).length;
    const containerDiv = this.container.createDiv("dashboard-stats");
    const statCards = [
      { label: "Total", value: stats.total, cls: "stat-total" },
      { label: "Active", value: stats.upcoming, cls: "stat-active" },
      { label: "Urgent", value: urgentCount, cls: "stat-urgent" },
      { label: "Overdue", value: stats.overdue, cls: "stat-overdue" },
      { label: "Completed", value: stats.completed, cls: "stat-completed" }
    ];
    statCards.forEach((stat) => {
      const card = containerDiv.createDiv({ cls: ["stat-card", stat.cls] });
      card.createDiv("stat-value").setText(String(stat.value));
      card.createDiv("stat-label").setText(stat.label);
    });
  }
};

// views/StatsView.ts
var VIEW_TYPE_STATS = "semester-stats-view";
var StatsView = class extends import_obsidian10.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.plugin.taskManager.on("tasks-updated", () => this.render());
  }
  getViewType() {
    return VIEW_TYPE_STATS;
  }
  getDisplayText() {
    return "Dashboard Stats";
  }
  getIcon() {
    return "bar-chart-3";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer) this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.render();
  }
  async onClose() {
    if (this.tabContainer) this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Statistics",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        }
      }
    );
    this.headerComponent.render();
    const stats = new StatsComponent(this.contentEl);
    stats.render(this.plugin.taskManager);
  }
};

// main.ts
var SemesterDashboardPlugin = class extends import_obsidian11.Plugin {
  async onload() {
    await this.loadSettings();
    const parser = new TaskParser(this.app, this.settings);
    this.taskManager = new TaskManager(parser, this.app);
    this.registerView(VIEW_TYPE_DASHBOARD, (leaf) => new DashboardView(leaf, this));
    this.registerView(VIEW_TYPE_TIMELINE, (leaf) => new TimelineView(leaf, this));
    this.registerView(VIEW_TYPE_LIST, (leaf) => new TaskListView(leaf, this));
    this.registerView(VIEW_TYPE_STATS, (leaf) => new StatsView(leaf, this));
    this.addRibbonIcon("move", "Toggle Dashboard Layout", () => this.toggleLayoutMode());
    this.addCommand({
      id: "open-dashboard",
      name: "Open Dashboard (All-in-One)",
      callback: () => this.activateView(VIEW_TYPE_DASHBOARD)
    });
    this.addCommand({
      id: "open-timeline",
      name: "Open Timeline View",
      callback: () => this.activateView(VIEW_TYPE_TIMELINE)
    });
    this.addCommand({
      id: "open-task-list",
      name: "Open Task List",
      callback: () => this.activateView(VIEW_TYPE_LIST)
    });
    this.addCommand({
      id: "open-stats",
      name: "Open Statistics",
      callback: () => this.activateView(VIEW_TYPE_STATS)
    });
    this.addCommand({
      id: "quick-add-task",
      name: "Quick Add Task",
      callback: () => {
        new QuickAddModal(this.app, this.taskManager).open();
      }
    });
    this.addCommand({
      id: "refresh-dashboard-styles",
      name: "Reload Dashboard Colors/Styles",
      callback: () => this.refreshViews()
    });
    this.addSettingTab(new SettingsTab(this.app, this));
  }
  toggleLayoutMode() {
    const viewTypes = [VIEW_TYPE_DASHBOARD, VIEW_TYPE_TIMELINE, VIEW_TYPE_LIST, VIEW_TYPE_STATS];
    let anyUnlocked = false;
    viewTypes.forEach((type) => {
      const leaves = this.app.workspace.getLeavesOfType(type);
      leaves.forEach((leaf) => {
        const tabContainer = leaf.view.containerEl.closest(".workspace-tabs");
        if (tabContainer) {
          if (tabContainer.classList.contains("semester-hide-tabs")) {
            tabContainer.classList.remove("semester-hide-tabs");
            anyUnlocked = true;
          } else {
            tabContainer.classList.add("semester-hide-tabs");
          }
        }
      });
    });
    new import_obsidian11.Notice(anyUnlocked ? "Dashboard Layout: Unlocked \u{1F513}" : "Dashboard Layout: Locked \u{1F512}");
  }
  async activateView(viewType) {
    const leaf = this.app.workspace.getLeaf(true);
    await leaf.setViewState({ type: viewType, active: true });
    this.app.workspace.revealLeaf(leaf);
    setTimeout(() => {
      const tabContainer = leaf.view.containerEl.closest(".workspace-tabs");
      if (tabContainer) tabContainer.classList.add("semester-hide-tabs");
    }, 100);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.taskManager.loadTasks();
  }
  refreshViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_DASHBOARD);
    leaves.forEach((leaf) => {
      const view = leaf.view;
      const isDashboard = typeof (view == null ? void 0 : view.getViewType) === "function" && view.getViewType() === VIEW_TYPE_DASHBOARD;
      const canRefresh = typeof (view == null ? void 0 : view.refreshFromSettings) === "function";
      if (isDashboard && canRefresh) {
        view.refreshFromSettings();
      }
    });
  }
};
