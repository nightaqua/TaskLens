/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SemesterDashboardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// models/Task.ts
function getTaskStatus(task) {
  if (task.completed) return "completed" /* Completed */;
  if (task.dueDate) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const due = new Date(task.dueDate);
    due.setHours(0, 0, 0, 0);
    if (due < today) return "overdue" /* Overdue */;
    const diffTime = due.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    if (diffDays <= 3 && diffDays >= 0) return "urgent" /* Urgent */;
    return "upcoming_week" /* UpcomingWeek */;
  }
  return "no_date" /* NoDate */;
}
function taskMatchesStatus(task, status) {
  if (status === "all" /* All */) {
    return true;
  }
  return getTaskStatus(task) === status;
}

// services/TaskManager.ts
var import_obsidian = require("obsidian");
var TaskManager = class extends import_obsidian.Events {
  constructor(parser) {
    super();
    this.parser = parser;
    this.tasks = [];
    this.filteredTasks = [];
    this.currentStatusFilter = "open" /* Open */;
    // Default to Open/Active
    this.currentCourseFilter = null;
    this.currentSortBy = "due-date" /* DueDate */;
  }
  /**
   * Load all tasks from vault
   */
  async loadTasks() {
    this.tasks = await this.parser.parseAllTasks();
    this.applyFiltersAndSort();
    this.trigger("tasks-updated", this.filteredTasks);
  }
  /**
   * Refresh tasks from a specific file
   */
  async refreshFileTask(filePath) {
    this.tasks = this.tasks.filter((t) => t.filePath !== filePath);
    const newTasks = await this.parser.parseTasksFromFilePath(filePath);
    this.tasks.push(...newTasks);
    this.applyFiltersAndSort();
    this.trigger("tasks-updated", this.filteredTasks);
  }
  /**
   * Get all tasks
   */
  getAllTasks() {
    return [...this.tasks];
  }
  /**
   * Get filtered and sorted tasks
   */
  getFilteredTasks() {
    return [...this.filteredTasks];
  }
  /**
   * Get unique course names
   */
  getCourseNames() {
    const courses = new Set(this.tasks.map((t) => t.fileName));
    return Array.from(courses).sort();
  }
  /**
   * Set status filter
   */
  setStatusFilter(status) {
    this.currentStatusFilter = status;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated", this.filteredTasks);
  }
  /**
   * Set course filter
   */
  setCourseFilter(course) {
    this.currentCourseFilter = course;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated", this.filteredTasks);
  }
  /**
   * Set sort order
   */
  setSortBy(sortBy) {
    this.currentSortBy = sortBy;
    this.applyFiltersAndSort();
    this.trigger("tasks-updated", this.filteredTasks);
  }
  /**
   * Get current filters
   */
  getCurrentFilters() {
    return {
      status: this.currentStatusFilter,
      course: this.currentCourseFilter,
      sortBy: this.currentSortBy
    };
  }
  /**
   * Apply current filters and sorting
   */
  applyFiltersAndSort() {
    this.filteredTasks = this.tasks.filter((task) => {
      if (this.currentStatusFilter !== "all" /* All */) {
        if (this.currentStatusFilter === "open" /* Open */) {
          if (task.completed) return false;
        } else {
          if (!taskMatchesStatus(task, this.currentStatusFilter)) return false;
        }
      }
      if (this.currentCourseFilter && task.fileName !== this.currentCourseFilter) {
        return false;
      }
      return true;
    });
    this.filteredTasks.sort((a, b) => {
      const weightA = this.getStatusWeight(a);
      const weightB = this.getStatusWeight(b);
      if (weightA !== weightB) {
        return weightA - weightB;
      }
      switch (this.currentSortBy) {
        case "due-date" /* DueDate */: {
          const byDue = this.compareDates(a.dueDate, b.dueDate);
          if (byDue !== 0) return byDue;
          return a.fileName.localeCompare(b.fileName);
        }
        case "start-date" /* StartDate */: {
          const byStart = this.compareDates(a.startDate, b.startDate);
          if (byStart !== 0) return byStart;
          return this.compareDates(a.dueDate, b.dueDate);
        }
        case "file-name" /* FileName */: {
          const byFile = a.fileName.localeCompare(b.fileName);
          if (byFile !== 0) return byFile;
          return this.compareDates(a.dueDate, b.dueDate);
        }
        default:
          return 0;
      }
    });
  }
  /**
   * Status priority weight (Overdue > Urgent > Open > Completed)
   * Note: "Open" is represented by UpcomingWeek + NoDate (i.e., not completed and not overdue/urgent)
   */
  getStatusWeight(task) {
    const status = getTaskStatus(task);
    switch (status) {
      case "overdue" /* Overdue */:
        return 1;
      // highest priority
      case "urgent" /* Urgent */:
        return 2;
      // high priority
      case "upcoming_week" /* UpcomingWeek */:
        return 3;
      // normal open
      case "no_date" /* NoDate */:
        return 4;
      // open, but less actionable
      case "completed" /* Completed */:
        return 5;
      // lowest priority
      default:
        return 3;
    }
  }
  /**
   * Compare two dates for sorting (null dates go to end)
   */
  compareDates(a, b) {
    if (!a && !b) return 0;
    if (!a) return 1;
    if (!b) return -1;
    return a.getTime() - b.getTime();
  }
  /**
   * Get statistics
   * - `upcoming` is the count of UpcomingWeek tasks (renamed from `upcomingWeek` to match the views)
   */
  getStatistics() {
    const total = this.tasks.length;
    const completed = this.tasks.filter((t) => t.completed).length;
    const overdue = this.tasks.filter((t) => getTaskStatus(t) === "overdue" /* Overdue */).length;
    const urgent = this.tasks.filter((t) => getTaskStatus(t) === "urgent" /* Urgent */).length;
    const upcoming = this.tasks.filter((t) => getTaskStatus(t) === "upcoming_week" /* UpcomingWeek */).length;
    const courses = this.getCourseNames().length;
    return {
      total,
      completed,
      overdue,
      urgent,
      upcoming,
      courses
    };
  }
};

// services/TaskParser.ts
var import_obsidian2 = require("obsidian");
var TaskParser = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Parse all tasks from the vault based on settings
   */
  async parseAllTasks() {
    const tasks = [];
    const filesToScan = this.getFilesToScan();
    for (const file of filesToScan) {
      const fileTasks = await this.parseTasksFromFile(file);
      tasks.push(...fileTasks);
    }
    return tasks;
  }
  /**
   * Get list of files to scan based on settings
   */
  getFilesToScan() {
    const allMarkdownFiles = this.app.vault.getMarkdownFiles();
    if (this.settings.scanFolders.length === 0) {
      return allMarkdownFiles;
    }
    return allMarkdownFiles.filter((file) => {
      return this.settings.scanFolders.some((folder) => {
        var _a;
        const normalizedFolder = folder.replace(/^\/|\/$/g, "");
        const filePath = file.path;
        if (this.settings.scanRecursively) {
          return filePath.startsWith(normalizedFolder);
        } else {
          const fileFolder = ((_a = file.parent) == null ? void 0 : _a.path) || "";
          return fileFolder === normalizedFolder;
        }
      });
    });
  }
  /**
   * Parse tasks from a single file
   */
  async parseTasksFromFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const cache = this.app.metadataCache.getFileCache(file);
    const courseName = this.getCourseName(file, cache);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const taskMatch = line.match(/^(\s*)-\s\[([ xX])\]\s(.+)$/);
      if (taskMatch) {
        const completed = taskMatch[2].toLowerCase() === "x";
        const taskText = taskMatch[3];
        const { title, startDate, dueDate } = this.parseTaskMetadata(taskText);
        const task = {
          id: `${file.path}:${i}`,
          title,
          completed,
          filePath: file.path,
          fileName: courseName,
          lineNumber: i,
          startDate,
          dueDate,
          originalText: line
        };
        tasks.push(task);
      }
    }
    return tasks;
  }
  /**
   * Get course name based on configured detection method
   */
  getCourseName(file, cache) {
    var _a;
    switch (this.settings.courseDetection) {
      case "per-file":
        return file.basename;
      case "per-folder":
        return ((_a = file.parent) == null ? void 0 : _a.name) || file.basename;
      case "frontmatter":
        if (cache == null ? void 0 : cache.frontmatter) {
          const courseValue = cache.frontmatter[this.settings.courseFrontmatterKey];
          if (courseValue) {
            return String(courseValue);
          }
        }
        return file.basename;
      default:
        return file.basename;
    }
  }
  /**
   * Parse inline metadata from task text
   * Extracts start:: and due:: dates and returns cleaned title
   */
  parseTaskMetadata(taskText) {
    let title = taskText;
    let startDate;
    let dueDate;
    const startMatch = taskText.match(/start::\s*(\d{4}-\d{2}-\d{2})/);
    if (startMatch) {
      startDate = new Date(startMatch[1]);
      title = title.replace(/start::\s*\d{4}-\d{2}-\d{2}\s*/g, "");
    }
    const dueMatch = taskText.match(/due::\s*(\d{4}-\d{2}-\d{2})/);
    if (dueMatch) {
      dueDate = new Date(dueMatch[1]);
      title = title.replace(/due::\s*\d{4}-\d{2}-\d{2}\s*/g, "");
    }
    if (!dueDate) {
      const emojiMatch = taskText.match(/ðŸ“…\s*(\d{4}-\d{2}-\d{2})/);
      if (emojiMatch) {
        dueDate = new Date(emojiMatch[1]);
        title = title.replace(/ðŸ“…\s*\d{4}-\d{2}-\d{2}\s*/g, "");
      }
    }
    title = title.trim();
    return { title, startDate, dueDate };
  }
  /**
   * Parse tasks from a specific file (used for updates)
   */
  async parseTasksFromFilePath(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian2.TFile) {
      return this.parseTasksFromFile(file);
    }
    return [];
  }
};

// settings/Settings.ts
var DEFAULT_SETTINGS = {
  scanFolders: [],
  scanRecursively: true,
  courseDetection: "per-file",
  courseFrontmatterKey: "course",
  startDateKey: "start",
  dueDateKey: "due",
  allowNoDueDate: true,
  showCompletedByDefault: false,
  defaultSort: "due-date",
  uiDensity: "comfortable",
  colorScheme: "inherit",
  customColors: {
    overdue: "#e74c3c",
    upcoming: "#f39c12",
    completed: "#27ae60"
  }
};

// settings/SettingsTab.ts
var import_obsidian3 = require("obsidian");
var SettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("semester-dashboard-settings");
    containerEl.createEl("h2", { text: "Personal Dashboard Settings" });
    const generalDetails = containerEl.createEl("details");
    generalDetails.open = true;
    generalDetails.createEl("summary", { text: "General Configuration" });
    new import_obsidian3.Setting(generalDetails).setName("Course Folders").setDesc("Specific folders to scan (comma separated). Leave empty to scan whole vault.").addText((text) => text.setPlaceholder("Uni/Sem1, Work/Projects").setValue(this.plugin.settings.scanFolders.join(", ")).onChange(async (value) => {
      this.plugin.settings.scanFolders = value.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
      await this.plugin.saveSettings();
    }));
    const parserDetails = containerEl.createEl("details");
    parserDetails.createEl("summary", { text: "Task Parsing" });
    new import_obsidian3.Setting(parserDetails).setName("Start Date Key").setDesc("Inline field for start date (e.g. start::)").addText((text) => text.setValue(this.plugin.settings.startDateKey).onChange(async (value) => {
      this.plugin.settings.startDateKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(parserDetails).setName("Due Date Key").setDesc("Inline field for due date (e.g. due::)").addText((text) => text.setValue(this.plugin.settings.dueDateKey).onChange(async (value) => {
      this.plugin.settings.dueDateKey = value;
      await this.plugin.saveSettings();
    }));
    const viewDetails = containerEl.createEl("details");
    viewDetails.createEl("summary", { text: "View Preferences" });
    new import_obsidian3.Setting(viewDetails).setName("Default View").setDesc("Choose what to show by default (Future feature)").addDropdown((drop) => drop.addOption("list", "List").addOption("timeline", "Timeline").setValue("list").setDisabled(true));
  }
};

// views/DashboardView.ts
var import_obsidian5 = require("obsidian");

// views/TimelineComponent.ts
var TimelineComponent = class {
  constructor(container, tasks, daysToShow = 7) {
    // Drag state
    this.isDragging = false;
    this.startX = 0;
    this.scrollLeft = 0;
    // The actual horizontally scrollable element (created in render)
    this.scrollContainer = null;
    this.todayColumnIndex = -1;
    this.container = container;
    this.tasks = tasks.filter((t) => t.dueDate);
    this.daysToShow = daysToShow;
  }
  render() {
    this.container.empty();
    this.container.addClass("timeline-wrapper");
    this.todayColumnIndex = -1;
    if (this.tasks.length === 0) {
      const scrollContainer = this.container.createDiv("timeline-container");
      const empty = scrollContainer.createDiv("dashboard-empty-state");
      empty.createEl("p", { text: "No dated tasks to display." });
      return;
    }
    this.createNavigationOverlay("left");
    this.createNavigationOverlay("right");
    this.scrollContainer = this.container.createDiv("timeline-container");
    this.setupEventListeners(this.scrollContainer);
    const dates = this.tasks.map((t) => [t.startDate, t.dueDate]).flat().filter((d) => !!d).sort((a, b) => a.getTime() - b.getTime());
    if (dates.length === 0) return;
    const minDate = new Date(dates[0]);
    minDate.setDate(minDate.getDate() - 14);
    const maxDate = new Date(dates[dates.length - 1]);
    maxDate.setDate(maxDate.getDate() + 14);
    const allDays = [];
    const current = new Date(minDate);
    while (current <= maxDate) {
      allDays.push(new Date(current));
      current.setDate(current.getDate() + 1);
    }
    const grid = this.scrollContainer.createDiv("timeline-grid");
    const colWidthPercent = 100 / this.daysToShow;
    grid.style.gridTemplateColumns = `repeat(${allDays.length}, ${colWidthPercent}%)`;
    const borderColor = "rgba(200, 200, 200, 0.15)";
    grid.style.backgroundImage = `linear-gradient(to right, transparent 0%, transparent calc(100% - 1px), ${borderColor} 100%)`;
    grid.style.backgroundSize = `${colWidthPercent}% 100%`;
    const todayStr = (/* @__PURE__ */ new Date()).toDateString();
    let todayColumn = -1;
    allDays.forEach((day, index) => {
      const isWeekend = day.getDay() === 0 || day.getDay() === 6;
      const cell = grid.createDiv("timeline-header-cell");
      if (isWeekend) cell.addClass("weekend");
      const dayName = day.toLocaleDateString(void 0, { weekday: "short" });
      const dayNum = day.getDate();
      const month = day.toLocaleDateString(void 0, { month: "short" });
      const label = dayNum === 1 || index === 0 ? `${month} ${dayNum}` : `${dayName} ${dayNum}`;
      cell.setText(label);
      cell.style.gridColumn = `${index + 1}`;
      cell.style.gridRow = "1";
      if (day.toDateString() === todayStr) {
        const marker = grid.createDiv("timeline-today-marker");
        marker.style.gridColumn = `${index + 1}`;
        todayColumn = index;
        this.todayColumnIndex = index;
      }
    });
    this.tasks.forEach((task, index) => {
      const taskStart = task.startDate ? task.startDate : task.dueDate;
      const taskEnd = task.dueDate;
      const startIndex = this.getDayDiff(minDate, taskStart) + 1;
      const endIndex = this.getDayDiff(minDate, taskEnd) + 1;
      const visualStart = Math.min(startIndex, endIndex);
      const visualEnd = Math.max(startIndex, endIndex);
      const bar = grid.createDiv("timeline-task-bar");
      bar.setText(task.title);
      const status = getTaskStatus(task);
      if (status === "overdue" /* Overdue */) bar.addClass("status-overdue");
      else if (status === "urgent" /* Urgent */) bar.addClass("status-urgent");
      else if (status === "completed" /* Completed */) bar.addClass("status-completed");
      else bar.addClass("status-active");
      bar.style.gridColumn = `${visualStart} / ${visualEnd + 1}`;
      bar.style.gridRow = `${index + 2}`;
      const dateStr = task.dueDate ? task.dueDate.toLocaleDateString() : "No date";
      bar.setAttribute("title", `${task.title}
${task.fileName}
Due: ${dateStr}`);
    });
    this.scrollToToday();
  }
  scrollToToday() {
    if (this.todayColumnIndex !== -1 && this.scrollContainer) {
      setTimeout(() => {
        if (!this.scrollContainer) return;
        const containerWidth = this.scrollContainer.clientWidth;
        const columnWidth = containerWidth / this.daysToShow;
        const scrollPos = this.todayColumnIndex * columnWidth - containerWidth / 2 + columnWidth / 2;
        this.scrollContainer.scrollTo({ left: scrollPos, behavior: "smooth" });
      }, 100);
    }
  }
  createNavigationOverlay(direction) {
    const overlay = this.container.createDiv(`timeline-nav-overlay nav-${direction}`);
    const arrow = overlay.createDiv("nav-arrow");
    arrow.setText(direction === "left" ? "\u2039" : "\u203A");
    overlay.addEventListener("click", (e) => {
      var _a;
      e.stopPropagation();
      const scroller = (_a = this.scrollContainer) != null ? _a : this.container.querySelector(".timeline-container");
      if (!scroller) return;
      const amount = scroller.clientWidth / 2;
      scroller.scrollBy({ left: direction === "left" ? -amount : amount, behavior: "smooth" });
    });
  }
  setupEventListeners(target) {
    target.addEventListener("mousedown", (e) => {
      this.isDragging = true;
      target.addClass("is-dragging");
      this.startX = e.pageX - target.offsetLeft;
      this.scrollLeft = target.scrollLeft;
    });
    target.addEventListener("mouseleave", () => {
      this.isDragging = false;
      target.removeClass("is-dragging");
    });
    target.addEventListener("mouseup", () => {
      this.isDragging = false;
      target.removeClass("is-dragging");
    });
    target.addEventListener("mousemove", (e) => {
      if (!this.isDragging) return;
      e.preventDefault();
      const x = e.pageX - target.offsetLeft;
      const walk = (x - this.startX) * 1.5;
      target.scrollLeft = this.scrollLeft - walk;
    });
  }
  scroll(direction) {
    var _a;
    const scroller = (_a = this.scrollContainer) != null ? _a : this.container;
    const scrollAmount = scroller.clientWidth / 2;
    const newPos = direction === "left" ? scroller.scrollLeft - scrollAmount : scroller.scrollLeft + scrollAmount;
    scroller.scrollTo({ left: newPos, behavior: "smooth" });
  }
  getDayDiff(start, end) {
    const oneDay = 1e3 * 60 * 60 * 24;
    const diff = end.getTime() - start.getTime();
    return Math.floor(diff / oneDay);
  }
};

// views/HeaderComponent.ts
var import_obsidian4 = require("obsidian");
var HeaderComponent = class {
  constructor(container, initialState, defaultTitle, callbacks) {
    this.headerEl = null;
    this.sidebarHandleEl = null;
    this.isSaving = false;
    this.container = container;
    this.defaultTitle = defaultTitle;
    this.title = initialState.title || defaultTitle;
    this.isCollapsed = initialState.isCollapsed || false;
    this.onStateChange = callbacks.onStateChange;
    this.onRefresh = callbacks.onRefresh;
    this.onSettings = callbacks.onSettings || null;
  }
  render() {
    this.renderSidebarHandle();
    this.renderHeader();
    this.updateVisibility();
  }
  renderSidebarHandle() {
    if (this.sidebarHandleEl) this.sidebarHandleEl.remove();
    this.sidebarHandleEl = this.container.createDiv("dashboard-sidebar-handle is-hidden");
    (0, import_obsidian4.setIcon)(this.sidebarHandleEl, "panel-left-open");
    this.sidebarHandleEl.setAttribute("aria-label", "Show Header");
    this.sidebarHandleEl.addEventListener("click", () => {
      this.isCollapsed = false;
      this.updateVisibility();
      this.onStateChange();
    });
  }
  renderHeader() {
    if (this.headerEl) this.headerEl.remove();
    this.headerEl = this.container.createDiv("dashboard-header");
    const leftGroup = this.headerEl.createDiv("header-actions-left");
    if (this.onSettings) {
      const settingsBtn = leftGroup.createEl("button", { cls: "header-icon-btn" });
      (0, import_obsidian4.setIcon)(settingsBtn, "settings");
      settingsBtn.addEventListener("click", () => this.onSettings());
    }
    const titleWrapper = this.headerEl.createDiv("dashboard-title-wrapper");
    titleWrapper.setAttribute("aria-label", "Click to rename");
    const titleEl = titleWrapper.createEl("h2", { text: this.title });
    const editIcon = titleWrapper.createDiv("edit-title-icon");
    (0, import_obsidian4.setIcon)(editIcon, "pencil");
    titleWrapper.addEventListener("click", () => {
      this.enterEditMode(titleWrapper);
    });
    const rightGroup = this.headerEl.createDiv("header-actions-right");
    const refreshBtn = rightGroup.createEl("button", { cls: "dashboard-refresh-btn header-icon-btn" });
    (0, import_obsidian4.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.setAttribute("aria-label", "Refresh Data");
    refreshBtn.addEventListener("click", () => {
      refreshBtn.addClass("is-rotating");
      this.onRefresh();
      setTimeout(() => refreshBtn.removeClass("is-rotating"), 1e3);
    });
    const hideBtn = rightGroup.createEl("button", { cls: "header-icon-btn" });
    (0, import_obsidian4.setIcon)(hideBtn, "panel-top-close");
    hideBtn.setAttribute("aria-label", "Hide Header");
    hideBtn.addEventListener("click", () => {
      this.isCollapsed = true;
      this.updateVisibility();
      this.onStateChange();
    });
  }
  enterEditMode(wrapper) {
    wrapper.empty();
    const input = wrapper.createEl("input", {
      type: "text",
      value: this.title,
      cls: "dashboard-title-input"
    });
    input.focus();
    input.select();
    this.isSaving = false;
    const save = () => {
      if (this.isSaving) return;
      this.isSaving = true;
      const newVal = input.value.trim();
      this.title = newVal.length > 0 ? newVal : this.defaultTitle;
      this.onStateChange();
    };
    input.addEventListener("blur", save);
    input.addEventListener("keydown", (e) => {
      e.stopPropagation();
      if (e.key === "Enter") {
        e.preventDefault();
        save();
      }
    });
    input.addEventListener("keypress", (e) => e.stopPropagation());
  }
  updateVisibility() {
    var _a, _b, _c, _d;
    if (this.isCollapsed) {
      (_a = this.headerEl) == null ? void 0 : _a.addClass("is-collapsed");
      (_b = this.sidebarHandleEl) == null ? void 0 : _b.removeClass("is-hidden");
    } else {
      (_c = this.headerEl) == null ? void 0 : _c.removeClass("is-collapsed");
      (_d = this.sidebarHandleEl) == null ? void 0 : _d.addClass("is-hidden");
    }
  }
  getState() {
    return {
      title: this.title,
      isCollapsed: this.isCollapsed
    };
  }
};

// views/DashboardView.ts
var VIEW_TYPE_DASHBOARD = "semester-dashboard-view";
var DashboardView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.timelineComponent = null;
    // Ref to access scrollToToday
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    // UI State
    this.showControls = true;
    this.showTimeline = true;
    this.showList = true;
    this.showStats = true;
    this.timelineDaysToShow = 7;
    this.taskManager = this.plugin.taskManager;
    this.taskManager.on("tasks-updated", () => this.render());
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file.path.endsWith(".md")) this.taskManager.refreshFileTask(file.path);
      })
    );
    this.taskManager.setStatusFilter("open" /* Open */);
  }
  getViewType() {
    return VIEW_TYPE_DASHBOARD;
  }
  getDisplayText() {
    return "Personal Dashboard";
  }
  getIcon() {
    return "layout-dashboard";
  }
  // --- Persistence Logic ---
  async setState(state, result) {
    var _a, _b, _c, _d, _e;
    if (state) {
      this.showControls = (_a = state.showControls) != null ? _a : this.showControls;
      this.showTimeline = (_b = state.showTimeline) != null ? _b : this.showTimeline;
      this.showList = (_c = state.showList) != null ? _c : this.showList;
      this.showStats = (_d = state.showStats) != null ? _d : this.showStats;
      this.timelineDaysToShow = (_e = state.timelineDaysToShow) != null ? _e : this.timelineDaysToShow;
      if (state.statusFilter) this.taskManager.setStatusFilter(state.statusFilter);
      if (state.courseFilter) this.taskManager.setCourseFilter(state.courseFilter);
      if (state.headerState) this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    const filters = this.taskManager.getCurrentFilters();
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return {
      showControls: this.showControls,
      showTimeline: this.showTimeline,
      showList: this.showList,
      showStats: this.showStats,
      timelineDaysToShow: this.timelineDaysToShow,
      statusFilter: filters.status,
      courseFilter: filters.course,
      headerState: this.headerState
    };
  }
  // -------------------------
  async onOpen() {
    const parent = this.containerEl.closest(".workspace-leaf-content");
    if (parent) parent.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer) this.tabContainer.classList.add("semester-hide-tabs");
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.contentEl.style.setProperty("--color-red", "#e63946");
    this.contentEl.style.setProperty("--color-orange", "#fb8500");
    this.contentEl.style.setProperty("--color-green", "#2a9d8f");
    this.contentEl.style.setProperty("--color-blue", "#457b9d");
    this.contentEl.style.setProperty("--color-purple", "#7209b7");
    await this.taskManager.loadTasks();
    this.render();
  }
  // 3. Remove class on close
  async onClose() {
    if (this.tabContainer) this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Personal Dashboard",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.taskManager.loadTasks();
          if (this.timelineComponent) {
            this.timelineComponent.scrollToToday();
          }
        },
        onSettings: () => {
          this.showControls = !this.showControls;
          this.app.workspace.requestSaveLayout();
          this.render();
        }
      }
    );
    this.headerComponent.render();
    this.renderControls();
    const layoutOrder = ["stats", "timeline", "list"];
    layoutOrder.forEach((component) => {
      if (component === "stats" && this.showStats) this.renderStatistics();
      if (component === "timeline" && this.showTimeline) this.renderTimeline();
      if (component === "list" && this.showList) this.renderTaskList();
    });
  }
  renderControls() {
    if (!this.showControls) return;
    const controls = this.contentEl.createDiv("dashboard-controls");
    const filtersDiv = controls.createDiv("filters-wrapper");
    filtersDiv.style.display = "flex";
    filtersDiv.style.gap = "12px";
    filtersDiv.style.flexWrap = "wrap";
    const statusGroup = filtersDiv.createDiv("control-group");
    statusGroup.createEl("label", { text: "Show:" });
    const statusSelect = statusGroup.createEl("select");
    const statusOptions = [
      { value: "open" /* Open */, label: "Active" },
      // Green
      { value: "all" /* All */, label: "All Tasks" },
      { value: "completed" /* Completed */, label: "Completed" }
    ];
    statusOptions.forEach((opt) => {
      const option = statusSelect.createEl("option", { value: opt.value, text: opt.label });
      if (opt.value === this.taskManager.getCurrentFilters().status) option.selected = true;
    });
    statusSelect.addEventListener("change", () => {
      this.taskManager.setStatusFilter(statusSelect.value);
    });
    const courseGroup = filtersDiv.createDiv("control-group");
    courseGroup.createEl("label", { text: "Topic:" });
    const courseSelect = courseGroup.createEl("select");
    courseSelect.createEl("option", { value: "", text: "All Topics" });
    this.taskManager.getCourseNames().forEach((course) => {
      const option = courseSelect.createEl("option", { value: course, text: course });
      if (course === this.taskManager.getCurrentFilters().course) option.selected = true;
    });
    courseSelect.addEventListener("change", () => {
      this.taskManager.setCourseFilter(courseSelect.value || null);
    });
    const actionsDiv = controls.createDiv("actions-wrapper");
    actionsDiv.style.display = "flex";
    actionsDiv.style.gap = "12px";
    actionsDiv.style.alignItems = "center";
    const toggleTimeline = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showTimeline ? "is-active" : ""}`,
      text: "Timeline"
    });
    toggleTimeline.addEventListener("click", () => {
      this.showTimeline = !this.showTimeline;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
    const toggleList = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showList ? "is-active" : ""}`,
      text: "List"
    });
    toggleList.addEventListener("click", () => {
      this.showList = !this.showList;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
    const statsBtn = actionsDiv.createEl("button", {
      cls: `view-toggle-btn ${this.showStats ? "is-active" : ""}`,
      text: "Stats"
    });
    statsBtn.addEventListener("click", () => {
      this.showStats = !this.showStats;
      this.app.workspace.requestSaveLayout();
      this.render();
    });
  }
  renderStatistics() {
    const stats = this.taskManager.getStatistics();
    const allTasks = this.taskManager.getAllTasks();
    const activeCount = allTasks.filter((t) => !t.completed).length;
    const container = this.contentEl.createDiv("dashboard-stats");
    const statCards = [
      { label: "Total", value: stats.total, cls: "stat-total" },
      // Purple
      { label: "Active", value: activeCount, cls: "stat-active" },
      // Green
      { label: "Urgent", value: stats.urgent, cls: "stat-urgent" },
      // Orange
      { label: "Overdue", value: stats.overdue, cls: "stat-overdue" },
      // Red
      { label: "Completed", value: stats.completed, cls: "stat-completed" }
      // Blue
    ];
    statCards.forEach((stat) => {
      const card = container.createDiv({ cls: ["stat-card", stat.cls] });
      card.createDiv("stat-value").setText(String(stat.value));
      card.createDiv("stat-label").setText(stat.label);
    });
  }
  renderTaskList() {
    const tasks = this.taskManager.getFilteredTasks();
    const listContainer = this.contentEl.createDiv("dashboard-task-list");
    if (tasks.length === 0) {
      const empty = listContainer.createDiv("dashboard-empty-state");
      empty.createEl("p", { text: "No tasks found." });
      return;
    }
    tasks.forEach((task) => {
      const status = getTaskStatus(task);
      let statusClass = "status-active";
      if (status === "overdue" /* Overdue */) statusClass = "status-overdue";
      if (status === "urgent" /* Urgent */) statusClass = "status-urgent";
      if (status === "completed" /* Completed */) statusClass = "status-completed";
      const taskEl = listContainer.createDiv({ cls: ["task-item", statusClass] });
      const checkbox = taskEl.createEl("input", { type: "checkbox", cls: "task-checkbox" });
      checkbox.checked = task.completed;
      checkbox.addEventListener("change", () => this.toggleTaskCompletion(task));
      const content = taskEl.createDiv("task-content");
      content.createDiv("task-title").setText(task.title);
      const meta = content.createDiv("task-meta");
      meta.createSpan("task-course").setText(task.fileName);
      if (task.dueDate) meta.createSpan("task-date").setText(`Due: ${this.formatDate(task.dueDate)}`);
      content.querySelector(".task-title").addEventListener("click", () => {
        this.openTaskInEditor(task);
      });
    });
  }
  formatDate(date) {
    const d = date.getDate().toString().padStart(2, "0");
    const m = (date.getMonth() + 1).toString().padStart(2, "0");
    const y = date.getFullYear();
    return `${d}-${m}-${y}`;
  }
  renderTimeline() {
    const container = this.contentEl.createDiv("dashboard-timeline-view");
    const controls = container.createDiv("timeline-controls");
    const zoomControls = controls.createDiv("zoom-controls");
    zoomControls.createSpan({ text: "Zoom: " });
    const zoomOut = zoomControls.createEl("button", { text: "-", cls: "view-toggle-btn" });
    zoomOut.addEventListener("click", () => {
      this.timelineDaysToShow = Math.min(30, this.timelineDaysToShow + 1);
      this.render();
    });
    zoomControls.createSpan({ text: ` ${this.timelineDaysToShow} Days ` });
    const zoomIn = zoomControls.createEl("button", { text: "+", cls: "view-toggle-btn" });
    zoomIn.addEventListener("click", () => {
      this.timelineDaysToShow = Math.max(3, this.timelineDaysToShow - 1);
      this.render();
    });
    const navControls = controls.createDiv("nav-controls");
    const scrollLeft = navControls.createEl("button", { cls: "view-toggle-btn" });
    (0, import_obsidian5.setIcon)(scrollLeft, "chevron-left");
    const scrollRight = navControls.createEl("button", { cls: "view-toggle-btn" });
    (0, import_obsidian5.setIcon)(scrollRight, "chevron-right");
    this.timelineComponent = new TimelineComponent(container, this.taskManager.getFilteredTasks(), this.timelineDaysToShow);
    this.timelineComponent.render();
    scrollLeft.addEventListener("click", () => {
      var _a;
      return (_a = this.timelineComponent) == null ? void 0 : _a.scroll("left");
    });
    scrollRight.addEventListener("click", () => {
      var _a;
      return (_a = this.timelineComponent) == null ? void 0 : _a.scroll("right");
    });
  }
  // ... Helpers (toggleTaskCompletion, openTaskInEditor) remain same ...
  async toggleTaskCompletion(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber]) {
        lines[task.lineNumber] = lines[task.lineNumber].includes("[x]") ? lines[task.lineNumber].replace("[x]", "[ ]") : lines[task.lineNumber].replace("[ ]", "[x]");
        await this.app.vault.modify(file, lines.join("\n"));
      }
    }
  }
  async openTaskInEditor(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        view.editor.setCursor({ line: task.lineNumber, ch: 0 });
        view.editor.scrollIntoView({ from: { line: task.lineNumber, ch: 0 }, to: { line: task.lineNumber, ch: 0 } }, true);
      }
    }
  }
};

// views/TimelineView.ts
var import_obsidian6 = require("obsidian");
var VIEW_TYPE_TIMELINE = "semester-timeline-view";
var TimelineView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.plugin.taskManager.on("tasks-updated", () => this.render());
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "Timeline";
  }
  getIcon() {
    return "calendar-range";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer) this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.contentEl.addClass("is-single-view");
    await this.plugin.taskManager.loadTasks();
    this.render();
  }
  async onClose() {
    if (this.tabContainer) this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Timeline",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        }
      }
    );
    this.headerComponent.render();
    const timeline = new TimelineComponent(this.contentEl, this.plugin.taskManager.getFilteredTasks(), 7);
    timeline.render();
  }
};

// views/TaskListView.ts
var import_obsidian8 = require("obsidian");

// views/TaskListComponent.ts
var import_obsidian7 = require("obsidian");
var TaskListComponent = class {
  constructor(container, app) {
    this.container = container;
    this.app = app;
  }
  render(tasks, onToggle) {
    this.container.empty();
    if (tasks.length === 0) {
      const empty = this.container.createDiv("dashboard-empty-state");
      empty.createEl("p", { text: "No tasks found." });
      return;
    }
    const listContainer = this.container.createDiv("dashboard-task-list");
    tasks.forEach((task) => {
      const status = getTaskStatus(task);
      let statusClass = "status-active";
      if (status === "overdue" /* Overdue */) statusClass = "status-overdue";
      if (status === "urgent" /* Urgent */) statusClass = "status-urgent";
      if (status === "completed" /* Completed */) statusClass = "status-completed";
      const taskEl = listContainer.createDiv({ cls: ["task-item", statusClass] });
      const checkbox = taskEl.createEl("input", { type: "checkbox", cls: "task-checkbox" });
      checkbox.checked = task.completed;
      checkbox.addEventListener("change", () => onToggle(task));
      const content = taskEl.createDiv("task-content");
      content.createDiv("task-title").setText(task.title);
      const meta = content.createDiv("task-meta");
      meta.createSpan("task-course").setText(task.fileName);
      if (task.dueDate) meta.createSpan("task-date").setText(`Due: ${task.dueDate.toLocaleDateString()}`);
      const titleEl = content.querySelector(".task-title");
      titleEl.addEventListener("click", () => this.openTaskInEditor(task));
    });
  }
  async openTaskInEditor(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (view) {
        view.editor.setCursor({ line: task.lineNumber, ch: 0 });
        view.editor.scrollIntoView({ from: { line: task.lineNumber, ch: 0 }, to: { line: task.lineNumber, ch: 0 } }, true);
      }
    }
  }
};

// views/TaskListView.ts
var VIEW_TYPE_LIST = "semester-list-view";
var TaskListView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.isOpen = false;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.onTasksUpdated = () => {
      var _a;
      if (!this.isOpen || !((_a = this.contentEl) == null ? void 0 : _a.isConnected)) return;
      this.render();
    };
    this.plugin.taskManager.on("tasks-updated", this.onTasksUpdated);
  }
  getViewType() {
    return VIEW_TYPE_LIST;
  }
  getDisplayText() {
    return "Task List";
  }
  getIcon() {
    return "list-todo";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer) this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.contentEl.addClass("is-single-view");
    this.isOpen = true;
    this.render();
  }
  async onClose() {
    this.isOpen = false;
    if (this.tabContainer) this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    var _a;
    if (!this.isOpen || !((_a = this.contentEl) == null ? void 0 : _a.isConnected)) return;
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "My Tasks",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        }
      }
    );
    this.headerComponent.render();
    const list = new TaskListComponent(this.contentEl, this.app);
    list.render(this.plugin.taskManager.getFilteredTasks(), (t) => this.toggleTask(t));
  }
  async toggleTask(task) {
    const file = this.app.vault.getAbstractFileByPath(task.filePath);
    if (file) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (lines[task.lineNumber]) {
        lines[task.lineNumber] = lines[task.lineNumber].includes("[x]") ? lines[task.lineNumber].replace("[x]", "[ ]") : lines[task.lineNumber].replace("[ ]", "[x]");
        await this.app.vault.modify(file, lines.join("\n"));
      }
    }
  }
};

// views/StatsView.ts
var import_obsidian9 = require("obsidian");

// views/StatsComponent.ts
var StatsComponent = class {
  constructor(container) {
    this.container = container;
  }
  render(taskManager) {
    this.container.empty();
    const stats = taskManager.getStatistics();
    const tasks = taskManager.getAllTasks();
    const urgentCount = tasks.filter((t) => !t.completed && getTaskStatus(t) === "urgent" /* Urgent */).length;
    const containerDiv = this.container.createDiv("dashboard-stats");
    const statCards = [
      { label: "Total", value: stats.total, cls: "stat-total" },
      { label: "Active", value: stats.upcoming, cls: "stat-active" },
      { label: "Urgent", value: urgentCount, cls: "stat-urgent" },
      { label: "Overdue", value: stats.overdue, cls: "stat-overdue" },
      { label: "Completed", value: stats.completed, cls: "stat-completed" }
    ];
    statCards.forEach((stat) => {
      const card = containerDiv.createDiv({ cls: ["stat-card", stat.cls] });
      card.createDiv("stat-value").setText(String(stat.value));
      card.createDiv("stat-label").setText(stat.label);
    });
  }
};

// views/StatsView.ts
var VIEW_TYPE_STATS = "semester-stats-view";
var StatsView = class extends import_obsidian9.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.leafRootEl = null;
    this.tabContainer = null;
    this.headerComponent = null;
    this.headerState = { title: null, isCollapsed: false };
    this.plugin.taskManager.on("tasks-updated", () => this.render());
  }
  getViewType() {
    return VIEW_TYPE_STATS;
  }
  getDisplayText() {
    return "Dashboard Stats";
  }
  getIcon() {
    return "bar-chart-3";
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.headerState) {
      this.headerState = state.headerState;
    }
    await super.setState(state, result);
    this.render();
  }
  getState() {
    if (this.headerComponent) {
      this.headerState = this.headerComponent.getState();
    }
    return { headerState: this.headerState };
  }
  async onOpen() {
    this.leafRootEl = this.containerEl.closest(".workspace-leaf-content");
    if (this.leafRootEl) this.leafRootEl.classList.add("semester-chromeless");
    this.tabContainer = this.containerEl.closest(".workspace-tabs");
    if (this.tabContainer) this.tabContainer.classList.add("semester-hide-tabs");
    this.contentEl.empty();
    this.contentEl.addClass("semester-dashboard-view");
    this.render();
  }
  async onClose() {
    if (this.tabContainer) this.tabContainer.classList.remove("semester-hide-tabs");
    if (this.leafRootEl) this.leafRootEl.classList.remove("semester-chromeless");
  }
  render() {
    this.contentEl.empty();
    this.headerComponent = new HeaderComponent(
      this.contentEl,
      this.headerState,
      "Statistics",
      {
        onStateChange: () => {
          if (this.headerComponent) {
            this.headerState = this.headerComponent.getState();
          }
          this.app.workspace.requestSaveLayout();
          this.render();
        },
        onRefresh: async () => {
          await this.plugin.taskManager.loadTasks();
        }
      }
    );
    this.headerComponent.render();
    const stats = new StatsComponent(this.contentEl);
    stats.render(this.plugin.taskManager);
  }
};

// main.ts
var SemesterDashboardPlugin = class extends import_obsidian10.Plugin {
  async onload() {
    await this.loadSettings();
    const parser = new TaskParser(this.app, this.settings);
    this.taskManager = new TaskManager(parser);
    this.registerView(VIEW_TYPE_DASHBOARD, (leaf) => new DashboardView(leaf, this));
    this.registerView(VIEW_TYPE_TIMELINE, (leaf) => new TimelineView(leaf, this));
    this.registerView(VIEW_TYPE_LIST, (leaf) => new TaskListView(leaf, this));
    this.registerView(VIEW_TYPE_STATS, (leaf) => new StatsView(leaf, this));
    this.addRibbonIcon("move", "Toggle Dashboard Layout", () => {
      this.toggleLayoutMode();
    });
    this.addCommand({
      id: "open-dashboard",
      name: "Open Dashboard (All-in-One)",
      callback: () => this.activateView(VIEW_TYPE_DASHBOARD)
    });
    this.addCommand({
      id: "open-timeline",
      name: "Open Timeline View",
      callback: () => this.activateView(VIEW_TYPE_TIMELINE)
    });
    this.addCommand({
      id: "open-task-list",
      name: "Open Task List",
      callback: () => this.activateView(VIEW_TYPE_LIST)
    });
    this.addCommand({
      id: "open-stats",
      name: "Open Statistics",
      callback: () => this.activateView(VIEW_TYPE_STATS)
    });
    this.addSettingTab(new SettingsTab(this.app, this));
  }
  // Toggle the "semester-hide-tabs" class on ALL dashboard leaves
  toggleLayoutMode() {
    const viewTypes = [VIEW_TYPE_DASHBOARD, VIEW_TYPE_TIMELINE, VIEW_TYPE_LIST, VIEW_TYPE_STATS];
    let anyUnlocked = false;
    viewTypes.forEach((type) => {
      const leaves = this.app.workspace.getLeavesOfType(type);
      leaves.forEach((leaf) => {
        const tabContainer = leaf.view.containerEl.closest(".workspace-tabs");
        if (tabContainer) {
          if (tabContainer.classList.contains("semester-hide-tabs")) {
            tabContainer.classList.remove("semester-hide-tabs");
            anyUnlocked = true;
          } else {
            tabContainer.classList.add("semester-hide-tabs");
          }
        }
      });
    });
    new import_obsidian10.Notice(anyUnlocked ? "Dashboard Layout: Unlocked \u{1F513}" : "Dashboard Layout: Locked \u{1F512}");
  }
  async activateView(viewType) {
    const leaf = this.app.workspace.getLeaf(true);
    await leaf.setViewState({ type: viewType, active: true });
    this.app.workspace.revealLeaf(leaf);
    setTimeout(() => {
      const tabContainer = leaf.view.containerEl.closest(".workspace-tabs");
      if (tabContainer) tabContainer.classList.add("semester-hide-tabs");
    }, 100);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.taskManager.loadTasks();
  }
};
